<!DOCTYPE html>
<html>
<head>
    <title>Release Burndown</title>

    <script type="text/javascript" src="/apps/x/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.DateMixin", {

        dateFormatters: [
            {key: "MMM", value: "%b"},
            {key: "MM", value: "%m"},
            {key: "dd", value: "%d"},
            {key: "yyyy", value: "%Y"}
        ],

        dateToStringDisplay: function (date) {
            return Ext.Date.format(date, 'm/d/Y');
        },

        dateToString: function (date) {
            return Ext.Date.format(date, 'Y-m-d\\TH:i:s.u\\Z');
        },

        dateStringToObject: function (dateStr) {
            var finalIndex = dateStr.indexOf('T'),
                dateObj;

            if (finalIndex > -1) {
                dateStr = dateStr.slice(0, dateStr.indexOf('T'));
            }

            dateObj = this._splitDateParts(dateStr);

            return new Date(dateObj.year, dateObj.month, dateObj.day);
        },

        _splitDateParts: function (dateStr) {
            if (this._shouldSplitOnDash(dateStr)) {
                return this._objectFromYearFirstDate(dateStr.split('-'));
            }
            else {
                return this._objectFromMonthFirstDate(dateStr.split('/'));
            }
        },

        _objectFromYearFirstDate: function (dateArray) {
            if (dateArray.length !== 3) {
                return { year: 0, month: 0, day: 0 };
            }

            dateArray[1] = (parseInt(dateArray[1], 10) - 1).toString();

            return {
                year: dateArray[0],
                month: dateArray[1],
                day: dateArray[2]
            };
        },

        _objectFromMonthFirstDate: function (dateArray) {
            if (dateArray.length !== 3) {
                return { year: 0, month: 0, day: 0 };
            }

            dateArray[0] = (parseInt(dateArray[0], 10) - 1).toString();

            return {
                month: dateArray[0],
                day: dateArray[1],
                year: dateArray[2]
            };
        },

        _shouldSplitOnDash: function (dateStr) {
            return dateStr.split('-').length === 3;
        }

    });

}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.IntegrationHeaders", {

        keyConverters : {
            name : function() { return 'X-RallyIntegrationName'; },
            vendor : function() { return 'X-RallyIntegrationVendor'; },
            platform : function() { return 'X-RallyIntegrationPlatform'; },
            os : function() { return 'X-RallyIntegrationOS'; },
            version : function() { return 'X-RallyIntegrationVersion'; },
            library : function() { return 'X-RallyIntegrationLibrary'; }
        },

        constructor: function(config) {
            this.headers = {
                name : 'A2 Chart',
                vendor : 'Rally Software'
            };

            Ext.merge(this.headers, config.integrationHeaders || {});
            this.callParent(config);
        },
        withName : function(nm) {
            this.headers.name = nm || this.headers.name;
            return this;
        },
        withVendor : function(v) {
            this.headers.vendor = v || this.headers.vendor;
            return this;
        },
        withPlatform : function(newPlatform) {
            this.headers.platform = newPlatform || this.headers.platform;
            return this;
        },
        withVersion : function(newVersion) {
            this.headers.version = newVersion || this.headers.version;
            return this;
        },
        withOS : function(newOS) {
            this.headers.os = newOS || this.headers.os;
            return this;
        },
        withLibrary : function(newLibrary) {
            this.headers.library = newLibrary || this.headers.library;
            return this;
        },
        applyTo : function(config) {
            config.headers = config.headers || {};
            Ext.merge(config.headers, this.build());
            return config;
        },
        build : function() {
            var h = {};
            for (var k in this.headers) {
                if (this.headers.hasOwnProperty(k)) {
                    if (this.headers[k] === null) { continue; }
                    var key = this._keyConverter(k)(k);
                    h[key] = this.headers[k];
                }
            }
            return h;
        },
        _keyConverter: function(key) {
            if (this.keyConverters.hasOwnProperty(key)) {
                return this.keyConverters[key];
            } else {
                return function(x) {return x;};
            }
        }
    });
}());

                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.RadioGroupSetting", {
        extend: "Ext.form.FieldContainer",

        config: {
            settingName: undefined
        },

        constructor: function(config) {
            this.mergeConfig(config);
            this.callParent(arguments);
        },

        getSetting: function() {
            return this.settingsParent.app.getSetting(this.settingName);
        },

        setRadioValue: function (cmp) {
            this.setRadioToCustomValue(cmp, this.getSetting());
        },

        setRadioToCustomValue: function (cmp, customValue) {
            var value = {};
            value[cmp.name] = customValue;
            cmp.setValue(value);
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.ChartDisplayTypePicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.chartdisplaytypepicker",

        mixins: [
            "Ext.form.field.Field"
        ],

        config: {
            settingName: "chartDisplayType"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this.add(this._getPicker());
        },

        _getPicker: function () {
            return {
                xtype: "radiogroup",
                name: this.settingName,
                columns: [160, 100],
                vertical: false,
                items: [
                    { boxLabel: "Line", name: this.settingName, inputValue: "line", checked: true },
                    { boxLabel: "Column", name: this.settingName, inputValue: "column" }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                }
            };
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.SettingsChangeMixin", {

        sendSettingsChange: function(artifact) {
            if (this.settingsParent) {
                this.settingsParent.sendSettingsChange(artifact, this);
            }
        },

        receiveSettingsChange: function(artifact) {

        }

    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.DataTypePicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.chartdatatypepicker",

        mixins: [
            "Ext.form.field.Field",
            "Rally.apps.charts.settings.SettingsChangeMixin"
        ],

        config: {
            settingName: "chartAggregationType"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this.add(this._addRadioGroup());
        },

        _addRadioGroup: function () {
            return {
                xtype: "radiogroup",
                name: this.settingName,
                columns: [160, 100],
                vertical: false,
                items: [
                    { boxLabel: "Story Plan Estimate", name: this.settingName, inputValue: "storypoints", checked: true },
                    { boxLabel: "Story Count", name: this.settingName, inputValue: "storycount" }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                }
            };
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.TimeboxPicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.charttimeboxpicker",

        mixins: [
            "Ext.form.field.Field"
        ],

        config: {
            settingName: "chartTimebox"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this._addRadioGroup();
        },

        _addRadioGroup: function () {
            this.add({
                xtype: "radiogroup",
                name: this.settingName,
                itemId: this.settingName,
                label: "Level",
                columns: [160, 100, 100],
                vertical: false,
                items: [
                    { boxLabel: "Release", name: this.settingName, inputValue: "release", checked: true },
                    { boxLabel: "Iteration", name: this.settingName, inputValue: "iteration" }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                },
                config: {
                    cls: "levelchooser"
                }
            });
        }
    });
}());

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Abstract class to handle expanding / collapsing for banner widgets
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.BannerWidget', {
        extend: 'Ext.Component',
        alias: 'widget.bannerwidget',

        config: {
            expanded: true
        },

        cls: 'stat-panel',

        data: {},

        tpl: [
            '<div class="expanded-widget"></div>',
            '<div class="collapsed-widget"></div>'
        ],

        onRender: function() {
            if (this.expanded) {
                this.removeCls('collapsed');
            } else {
                this.addCls('collapsed');
            }
            this.callParent(arguments);
        },

        expand: function() {
            this.removeCls('collapsed');
            this.setExpanded(true);
        },

        collapse: function() {
            this.addCls('collapsed');
            this.setExpanded(false);
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * gauge chart for stats banner
     * abstract class
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Gauge', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannergauge',

        requires: [
            'Rally.ui.chart.Chart',
            'Rally.util.Timebox',
            'Rally.util.Colors'
        ],

        config: {
            context: null,
            store: null
        },

        onDataChanged: Ext.emptyFn,
        getChartEl: Ext.emptyFn,
        _getChartConfig: Ext.emptyFn,

        _tzOffsetPromises: {},

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        expand: function() {
            this.callParent();
            if (this.chart) {
                this.chart.doLayout();
            } else {
                this._addChart(this._getChartConfig({}));
            }
        },

        onRender: function() {
            this.callParent(arguments);
            if (!this.getContext().getTimeboxScope().getRecord()) {
                this._addEmptyChart();
            }
        },

        _addEmptyChart: function() {
            this._cleanupChart();
            this._addChart({
                chartData: {
                    series: [{
                        data: [
                            {
                                name: '',
                                y: 100,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            });
        },

        _cleanupChart: function () {
            if (this.chart) {
                this.chart.destroy();
                delete this.chart;
            }
        },

        onDestroy: function () {
            this._cleanupChart();
            this.callParent(arguments);
        },

        onResize: function() {
            if (this.chart && !this.getEl().up('.stats-banner.collapsed')) {
                this.chart.updateLayout();
            }
            this.callParent(arguments);
        },

        refreshChart: function(chartConfig) {
            Ext.suspendLayouts();
            this._cleanupChart();
            if (this.rendered && this.expanded) {
                this._addChart(chartConfig);
            }
            Ext.resumeLayouts();
            this.fireEvent('ready', this);
        },

        _addChart: function(chartConfig) {
            var height = 62;
            this.chart = Ext.create('Rally.ui.chart.Chart', Ext.apply({
                loadMask: false,
                renderTo: this.getChartEl(),
                cls: 'gauge',
                chartConfig: {
                    chart: {
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        defaultSeriesType: 'pie',
                        height: height,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0
                    },
                    plotOptions: {
                        pie: {
                            borderWidth: 0,
                            center: ['50%', '50%'],
                            dataLabels: {
                                enabled: false
                            },
                            size: height - 4,
                            innerSize: height - 14,
                            enableMouseTracking: false, //turns off chart hover, but for tooltips you'll need this on
                            shadow: false
                        }
                    },
                    title: '',
                    tooltip: {
                        enabled: false
                    }
                }
            }, chartConfig));
        },

        getTimeboxData: function() {
            return this._getTZOffset().then({
                success: function (tzOffset) {
                    var timebox = this.getContext().getTimeboxScope().getRecord();
                    if(timebox) {
                        return Rally.util.Timebox.getCounts(
                            timebox.get('ReleaseStartDate'),
                            timebox.get('ReleaseDate'),
                            this.getContext().getWorkspace().WorkspaceConfiguration.WorkDays,
                            tzOffset);
                    } else {
                        return {
                            remaining: 0,
                            workdays: 0
                        };
                    }
                },
                scope: this
            });
        },

        _getTZOffset: function() {
            var projectRef = Rally.util.Ref.getRelativeUri(this.getContext().getProject());
            if (!Ext.isDefined(this._tzOffsetPromises[projectRef])) {
                var deferred = this._tzOffsetPromises[projectRef] = Ext.create('Deft.Deferred');
                Rally.environment.getIoProvider().httpGet({
                    url: Rally.environment.getServer().getWsapiUrl() + '/iteration',
                    params: {
                        includeSchema: true,
                        pagesize:1,
                        fetch: false,
                        project: projectRef
                    },
                    success: function(results) {
                        deferred.resolve((results.Schema.properties.EndDate.format.tzOffset || 0) / 60);
                    },
                    requester: this,
                    scope: this
                });
            }
            return this._tzOffsetPromises[projectRef];
        },

        getAcceptanceData: function () {
            var scheduleStates = this.store.model.getField('ScheduleState').getAllowedStringValues();
            var acceptanceData = {
                accepted: 0,
                total: 0
            };
            var accepted = _.indexOf(scheduleStates, 'Accepted');
            _.each(this.store.getRange(), function (record) {
                if (_.indexOf(scheduleStates, record.get('ScheduleState')) >= accepted) {
                    acceptanceData.accepted += 1;
                }
                acceptanceData.total += 1;
            }, this);
            return acceptanceData;
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows planned velocity for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.PlannedVelocity', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.Gauge',
        alias:'widget.statsbannerplannedvelocity',
        require: ['Rally.util.Colors'],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Completed Features</div>',
            '<div class="stat-metric">',
            '<div class="metric-chart"></div>',
            '<div class="metric-chart-text percent-offset">',
            '{percentage}<div class="metric-percent">%</div>',
            '</div>',
            '<div class="metric-subtext">{estimate} of {plannedVelocity} {unit}</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="stat-title">Completed Features</div>',
            '<div class="stat-metric">{percentage}<span class="metric-percent">%</span></div>',
            '</div>'
        ],

        config: {
            data: {
                percentage: 0,
                estimate: 0,
                plannedVelocity: 0,
                unit: ''
            }
        },

        onDataChanged: function() {
            console.log("Inside onDataChanged");
            this._getRenderData().then({
                success: function(renderData){
                    this.update(renderData);
                    this.refreshChart(this._getChartConfig(renderData));
                },
                scope: this
            });
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },

        _getTimeboxUnits: function() {
            return this.getContext().getTimeboxScope().getType() === 'iteration' ?
                this.getContext().getWorkspace().WorkspaceConfiguration.IterationEstimateUnitName :
                this.getContext().getWorkspace().WorkspaceConfiguration.ReleaseEstimateUnitName;
        },

        _getRenderData: function() {
            console.log("Store: ", this.store);
            console.log("Records: ", this.store.getRange());
            var deferred = Ext.create('Deft.Deferred');
            var allFeatures = _.filter(this.store.getRange(), function(record){
                return record.get("_type") == "portfolioitem/feature";
            } );            
            var doneFeatures = _.reduce(allFeatures, function (total, feature){
                if (feature.get("State") !== null && feature.get("State").get("Name") == "Done") {
                    return total + 1;
                }
            }, 0); 

            if ( isNaN(doneFeatures) ) {
                doneFeatures = 0;
            }
            
             var data = {
                    estimate: doneFeatures,
                    percentage: doneFeatures/allFeatures.length,
                    plannedVelocity: allFeatures.length,
                    unit: ''
                };
            deferred.resolve(data);

            return deferred.promise;
        },

        _getChartConfig: function(renderData) {
            var percentage = renderData.percentage,
                percentagePlanned = percentage % 100 || 100,
                color = Rally.util.Colors.cyan_med,
                secondaryColor = Rally.util.Colors.grey1;

            if (percentage > 100) {
                color = Rally.util.Colors.blue;
                secondaryColor = Rally.util.Colors.cyan;
            } else if (percentage > 70) {
                color = Rally.util.Colors.cyan;
            } else if (percentage === 0) {
                color = Rally.util.Colors.grey1;
            }

            return {
                chartData: {
                    series: [{
                        data: [
                            {
                                name: 'Planned Estimate Total',
                                y: percentagePlanned,
                                color: color
                            },
                            {
                                name: '',
                                y: 100 - percentagePlanned,
                                color: secondaryColor
                            }
                        ]
                    }]
                }
            };
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows days remaining for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.TimeboxEnd', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.Gauge',
        alias:'widget.statsbannertimeboxend',
        requires: [
            'Rally.util.Timebox',
            'Rally.util.Colors'
        ],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">{type} End</div>',
            '<div class="stat-metric">',
            '<div class="metric-chart"></div>',
            '<div class="metric-chart-text">',
            '{remaining}',
            '</div>',
            '<div class="metric-subtext">{remaining} days left of {workdays}</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="stat-title">{type} End</div>',
            '<div class="stat-metric">{remaining}<span class="stat-metric-secondary"> days</span></div>',
            '</div>'
        ],

        config: {
            data: {
                type: 'Iteration',
                remaining: 0,
                workdays: 0
            }
        },

        onDataChanged: function() {
            this.getTimeboxData().then({
                success: this._onDataAssembled,
                scope: this
            });
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },


        _onDataAssembled: function (timeboxData) {
            var renderData = _.merge(
                {type: Ext.String.capitalize(this.getContext().getTimeboxScope().getType())},
                this.getAcceptanceData(),
                timeboxData
            );
            this.update(renderData);

            this.refreshChart(this._getChartConfig(renderData));
        },

        _getChartConfig: function (renderData) {
            var decimal = renderData.remaining / renderData.workdays,
                percentLeft = decimal < 1 ? Math.round(decimal * 100) : 0,
                color = Rally.util.Colors.cyan;

            if (renderData.total === 0) {
                color = Rally.util.Colors.grey1;
            } else if (percentLeft === 0) {
                color = renderData.accepted === renderData.total ? Rally.util.Colors.lime : Rally.util.Colors.blue;
            } else if (percentLeft <= 25) {
                color = Rally.util.Colors.blue;
            }

            return {
                chartData: {
                    series: [{
                        data: [
                            {
                                name: 'Days Done',
                                y: 100 - percentLeft,
                                color: color
                            },
                            {
                                name: 'Days Left',
                                y: percentLeft,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            };
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows defects active for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Defects', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannerdefects',
        requires: [],

        config: {
            context: null,
            store: null,
            data: {
                activeCount: 0
            }
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Defects</div>',
            '<div class="stat-metric">',
            '<div class="metric-icon icon-defect"></div>{activeCount}',
            '<div class="stat-secondary">Closed</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-defect"></span>',
            '<div class="stat-title">Defects Closed</div>',
            '<div class="stat-metric">{activeCount}</div>',
            '</div>'
        ],

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        onDataChanged: function() {
            this.update(this._getRenderData());
            this.fireEvent('ready', this);
        },

        _getActiveDefectCount: function() {
            var activeDefects = 0;
            _.each(this.store.getRange(), function(record){
                var defectSummary = record.get('Summary') && record.get('Summary').Defects;
                if (defectSummary) {
                    _.each(defectSummary.State, function(count, state) {
                        if (state == 'Closed') {
                            activeDefects += count;
                        }
                    }, this);
                } else if(record.self.typePath === 'defect' && record.get('State') == 'Closed') {
                    activeDefects++;
                }
            }, this);
            return activeDefects;
        },

        _getRenderData: function() {
            return {activeCount: this._getActiveDefectCount()};
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows accepted work units for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Accepted', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.Gauge',
        alias:'widget.statsbanneraccepted',
        requires: ['Rally.util.Colors'],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Accepted Stories</div>',
            '<div class="stat-metric">',
            '<div class="metric-chart"></div>',
            '<div class="metric-chart-text percent-offset">',
            '{percentage}<div class="metric-percent">%</div>',
            '</div>',
            '<div class="metric-subtext">{accepted} of {total}</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="stat-title">Accepted Stories</div>',
            '<div class="stat-metric">{percentage}<span class="metric-percent">%</span></div>',
            '</div>'
        ],

        config: {
            data: {
                percentage: 0,
                accepted: 0,
                total: 0,
                unit: ''
            }
        },

        onDataChanged: function () {
            this.getTimeboxData().then({
                success: this._onDataAssembled,
                scope: this
            });
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },

        _getTimeboxUnits: function() {
            return this.getContext().getTimeboxScope().getType() === 'iteration' ?
                    this.getContext().getWorkspace().WorkspaceConfiguration.IterationEstimateUnitName :
                    this.getContext().getWorkspace().WorkspaceConfiguration.ReleaseEstimateUnitName;
        },

        _getRenderData: function(timeboxData) {
            var data = _.merge(
                {unit: this._getTimeboxUnits()},
                this.getAcceptanceData(),
                timeboxData
            );

            data.accepted = Ext.util.Format.round(data.accepted, 2);
            data.total = Ext.util.Format.round(data.total, 2);
            data.percentage = Math.round((data.accepted / data.total) * 100) || 0;

            return data;
        },

        _onDataAssembled: function (timeboxData) {
            var renderData = this._getRenderData(timeboxData);
            this.update(renderData);

            this.refreshChart(this._getChartConfig(renderData));
        },

        _getChartConfig: function(renderData) {
            var color = Rally.util.Colors.cyan,
                daysRemaining = renderData.remaining / renderData.workdays,
                percentage = renderData.percentage;

            if (percentage === 100) {
                color = Rally.util.Colors.lime;
            } else if (daysRemaining === 0) {
                color = Rally.util.Colors.blue;
            }

            return {
                chartData: {
                    series: [{
                        data: [
                            {
                                name: 'Accepted',
                                y: percentage,
                                color: color
                            },
                            {
                                name: '',
                                y: 100 - percentage,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            };
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows completed tasks for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Tasks', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannertasks',
        requires: [],

        config: {
            context: null,
            store: null,
            data: {
                count: 0
            }
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Tasks</div>',
            '<div class="stat-metric">',
            '<span class="metric-icon icon-task"></span>{count}',
            '<div class="stat-secondary">Active</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-task"></span>',
            '<div class="stat-title">Tasks</div>',
            '<div class="stat-metric">{count}</div>',
            '</div>'
        ],

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        onDataChanged: function() {
            this.update(this._getRenderData());
            this.fireEvent('ready', this);
        },

        _getRenderData: function() {
            return {count: this._getTaskCount()};
        },

        _getTaskCount: function() {
            var taskCount = 0;
            _.each(this.store.getRange(), function(record){
                var taskSummary = record.get('Summary') && record.get('Summary').Tasks;
                if (taskSummary) {
                    _.each(taskSummary['state+blocked'], function(count, state) {
                        if (!Ext.String.startsWith(state, 'Completed')) {
                            taskCount += count;
                        }
                    }, this);
                }
            }, this);
            return taskCount;
        }
    });
})();
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressMixin", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        _configureYAxis: function(ticks, axis) {

            var intervalY = (this.chartComponentConfig.chartConfig.yAxis[axis].max - 0) / (ticks - 1);
            var ticksY = [];
            for (var i = 0; i < ticks; i++) {
                ticksY.push(i * intervalY);
            }
            this.chartComponentConfig.chartConfig.yAxis[axis].tickPositions = ticksY;
        },

        _configureYAxisIntervals: function () {
            var ticks = 5; // not much chart space, limit to 5
            this._configureYAxis(ticks, 0);
            if(this.chartType === "burndown") { // cumulative flow only has y axis 0
                this._configureYAxis(ticks, 1);
            }
        },

        _getElementValue: function (element) {
            if (element.textContent !== undefined) {
                return element.textContent;
            }
            return element.text;
        },
        
        _getStringValues: function (elements) {
            var i;
            var strings = [];
            for (i = 0; i < elements.length; i++) {
                strings.push(this._getElementValue(elements[i]));
            }
            return strings;
        },

        _getNumberValues: function (elements) {
            var i;
            var numbers = [];
            for (i = 0; i < elements.length; i++) {
                if(this._getElementValue(elements[i])) {
                    numbers.push(this._getElementValue(elements[i]).split(' ')[0] * 1);
                } else {
                    numbers.push(0);
                }

            }
            return numbers;
        },

        _computeMaxYAxisValue: function(series) {
            var i, j, max = 0.0;
            // sum each day's values and find the largest sum
            for(i=0; i < series[0].data.length; i++) {
                var val = 0.0;
                for(j=0; j < series.length; j++) {
                    // if is for insurance, _should_ always be true
                    if(series[j].data.length === series[0].data.length) {
                        val += series[j].data[i];
                    }
                }
                if(val > max) {
                    max = val;
                }
            }
            max = Math.ceil(max / 4) * 4;  // round up to multiple of 4 so we will create 5 integral tick marks

            return (max === 0) ? 4 : max;
        },

        _createChartDatafromXML: function (xml) {
            var parseXml;

            if (typeof window.DOMParser !== "undefined") {
                parseXml = function (xmlStr) {
                    return ( new window.DOMParser() ).parseFromString(xmlStr, "text/xml");
                };
            } else if (typeof window.ActiveXObject !== "undefined" &&
                new window.ActiveXObject("Microsoft.XMLDOM")) {
                parseXml = function (xmlStr) {
                    var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = "false";
                    xmlDoc.loadXML(xmlStr);
                    return xmlDoc;
                };
            } else {
                throw new Error("No XML parser found");
            }

            return parseXml(xml);
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressChart", {
            requires: [
                "Rally.ui.chart.Chart"
            ],

            chartComponentConfig: {
               xtype: "rallychart",
               suppressClientMetrics: true /* keeps rallychart::lookback query time from displaying in client metrics */
            }
        });
}());

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.BurndownChart", {
        alias: "widget.statsbannerburndownchart",
        extend: "Ext.Container",
        requires: [
            'Rally.ui.chart.Chart'
        ],
        mixins: [
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressMixin",
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressChart"
        ],

        currentScope: undefined,
        context: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Burndown',
        minimalMode: false,
        onChartDataLoaded: Ext.emptyFn,

        initComponent: function() {
            this.callParent(arguments);

            Ext.Ajax.request({
                url: '/slm/charts/itsc.sp',
                params: {
                    iterationOid: this.context.getTimeboxScope().getRecord().getId(),
                    cpoid: this.context.getProject().ObjectID
                },
                method: 'GET',
                withCredentials: true,
                success: function(response, request) {
                    this._loadData(response.responseText);
                },
                requester: this,
                scope: this
            });
        },

        _loadData: function(chartData) {
            var xmlDoc = this._createChartDatafromXML(chartData);
            this._createBurndownChartDatafromXML(xmlDoc);
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;

            return Ext.Object.merge({
                xtype: 'rallychart',
                chartColors: ["#005eb8", "#666666", "#8dc63f" ],
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartConfig: {
                    chart: {
                        height: this.height,
                        width: this.width,
                        spacingTop: 2,
                        spacingRight: 0,
                        spacingBottom: 8,
                        spacingLeft: 0,
                        zoomType: 'xy',
                        alignTicks: false,
                        animation: true,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    plotOptions: {
                        series: {
                            animation: true,
                            shadow: false,
                            borderWidth: 0,
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: false
                                    }
                                }
                            },
                            events: {
                                click: clickChartHandler
                            }
                        },
                        column: {
                            point: {
                               events: {
                                   click: clickChartHandler
                               }
                           }
                        }
                    },
                    legend: { enabled: true },
                    title: { text: null },
                    xAxis: {
                        tickmarkPlacement: 'on',
                        tickInterval: 1
                    },
                    yAxis: [
                        {
                            title: { text: null },
                            min: 0,
                            labels: { style: { color: "#005eb8" } }
                        },
                        {
                            title: { text: null },
                            min: 0,
                            opposite: true,
                            labels: { style: { color: "#8dc63f" } }
                        }
                    ]
                },
                chartData: {
                    categories: [],
                    series: [
                        {
                            name: "To Do",
                            type: "column",
                            data: [],
                            tooltip: { enabled: false }
                        },
                        {
                            name: "Ideal",
                            type: "line",
                            dashStyle: "Solid",
                            data: [],
                            marker : {
                               enabled : true,
                               radius : 3
                            },
                            tooltip: { enabled: false }
                        },
                        {
                            name: "Accepted",
                            type: "column",
                            data: [],
                            yAxis: 1,
                            tooltip: { enabled: false }
                        }
                    ]
               }
           }, overrides || {});
        },

        _createMinimalConfig: function(){
            var config = this._createChartConfig();
            delete config.chartConfig.xAxis;
            delete config.chartConfig.yAxis;
            delete config.chartData.series[1].marker;

            config = Ext.Object.merge(config, {
                chartConfig: {
                    chart: {
                        zoomType: ''
                    },
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    legend: { enabled: false },
                    xAxis: {
                        labels: { enabled: false },
                        tickPositions: []
                    },

                    yAxis: [
                        {
                            title: { text: null },
                            min: 0,
                            labels: { enabled: false }
                        },
                        {
                            title: { text: null },
                            min: 0,
                            opposite: true,
                            labels: { enabled: false }
                        }
                    ],
                    title: { text: null }
                }
            });
            return config;
        },

        _createBurndownChartDatafromXML: function (xmlDoc) {

            this.chartComponentConfig = this.minimalMode ? this._createMinimalConfig() : this._createChartConfig();

            var xmlChartData = xmlDoc.getElementsByTagName("chart_data")[0];
            var xmlChartValueText = xmlDoc.getElementsByTagName("chart_value_text")[0];
            var draw = xmlDoc.getElementsByTagName("draw")[0];
            var axis_value = xmlDoc.getElementsByTagName("axis_value")[1];

            var rows = xmlChartData.getElementsByTagName("row");

            // this makes no sense...The thing labeled Accepted in the <chart_data> element, isn't.
            // The thing that is Accepted, is buried in the <chart_value_text> element

            this.chartComponentConfig.chartData.categories = this._getStringValues(rows[0].getElementsByTagName("string")); // categories
            this.chartComponentConfig.chartData.series[0].data = this._getNumberValues(rows[1].getElementsByTagName("number")); //todo;
            this.chartComponentConfig.chartData.series[1].data = this._getNumberValues(rows[3].getElementsByTagName("number")); //ideal;
            this.chartComponentConfig.chartData.series[2].data = this._getNumberValues(xmlChartValueText.getElementsByTagName("row")[2].getElementsByTagName("number")); //accepted;
            this.chartComponentConfig.chartConfig.yAxis[0].max = axis_value.getAttribute("max") * 1;

            var texts = draw.getElementsByTagName("text");
            // find the last <text element with orientation="vertical_down" attribute, that's the max y-axis 2 setting
            for (i = 0; i < texts.length; i++) {
                if (texts[i].getAttribute("orientation") === "vertical_down") {
                    this.chartComponentConfig.chartConfig.yAxis[1].max = (this._getElementValue(texts[i]) * 1);
                }
            }
            this._configureYAxisIntervals();

            this.chartComponentConfig.chartConfig.xAxis.tickInterval = Math.floor(this.chartComponentConfig.chartData.series[0].data.length / 4);

            this.add(this.chartComponentConfig);
        },

        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        }
    });
})();

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.CumulativeFlowChart", {
        alias: "widget.statsbannercumulativeflowchart",
        extend: "Ext.Container",
        requires: [ 'Rally.ui.chart.Chart' ],
        mixins: [
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressMixin",
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressChart"
        ],
        cls: 'rally-iteration-progress-cumulative-flow-chart',
        currentScope: undefined,
        context: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Cumulative Flow',
        minimalMode: false,
        initComponent: function() {
            this.callParent(arguments);

            Ext.Ajax.request({
                url: '/slm/charts/rcfc.sp',
                params: {
                    releaseOid: this.context.getTimeboxScope().getRecord().getId(),
                    cpoid: this.context.getProject().ObjectID,
                    bigChart: true
                },
                method: 'GET',
                withCredentials: true,
                success: function(response, request) {
                    this._loadData(response.responseText);
                },
                requester: this,
                scope: this
            });
        },

        _loadData: function(chartData) {
            var xmlDoc = this._createChartDatafromXML(chartData);
            this._createCumulativeFlowChartDatafromXML(xmlDoc);
        },

        _createMinimalConfig: function(){
            var config = this._createChartConfig();
            delete config.chartConfig.xAxis;
            delete config.chartConfig.yAxis;

            return Ext.Object.merge(config, {
                chartConfig: {
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    legend: { enabled: false },
                    xAxis: {
                        labels: { enabled: false },
                        tickPositions: []
                    },
                    yAxis: [{
                        title: {
                            text: null
                        },
                        min: 0,
                        labels: { enabled: false }
                    }],
                    title: { text: null }
                }
            });
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;

            return Ext.Object.merge({
                xtype: 'rallychart',
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartColors: [  // RGB values obtained from here: http://ux-blog.rallydev.com/?cat=23
                                "#C0C0C0",  // $grey4
                                "#FF8200",  // $orange
                                "#F6A900",  // $gold
                                "#FAD200",  // $yellow
                                "#CADDA3",  // $lime
                                "#1E7C00"
                            ],
                chartConfig: {
                    chart: {
                        height: this.height,
                        width: this.width,
                        spacingTop: 2,
                        spacingRight: 0,
                        spacingBottom: 8,
                        spacingLeft: 0,
                        alignTicks: false,
                        animation: true,
                        type: "area",
                        events: {
                            click: clickChartHandler
                        }
                    },
                    plotOptions: {
                        series: {
                            animation: true,
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        area: {
                            point: {
                                events: {
                                    click: clickChartHandler
                                }
                            },
                            stacking: 'normal'
                        }
                    },
                    legend: {
                        enabled: true
                    },
                    title: { text: null },
                    xAxis: {
                        tickmarkPlacement: 'on',
                        tickInterval: 1
                    },
                    yAxis: [{
                        title: { text: null },
                        min: 0,
                        labels: {
                            style: { color: "#005eb8" }
                        }
                    }]
                },
                chartData: {
                   categories: [],
                   series: []
                }
           }, overrides || {});
        },

        _createCumulativeFlowChartDatafromXML: function (xmlDoc) {

            this.chartComponentConfig = this.minimalMode ? this._createMinimalConfig() : this._createChartConfig();

            var xmlChartData = xmlDoc.getElementsByTagName("chart_data")[0];

            var rows = xmlChartData.getElementsByTagName("row");
            var i, j;
            this.chartComponentConfig.chartData.categories = this._getStringValues(rows[0].getElementsByTagName("string")); // categories
            for(j=rows.length-1, i = 0 ; j > 0; j--,i++) {
                this.chartComponentConfig.chartData.series[i] = {};
                this.chartComponentConfig.chartData.series[i].data = this._getNumberValues(rows[j].getElementsByTagName("number"));
                this.chartComponentConfig.chartData.series[i].name = this._getStringValues(rows[j].getElementsByTagName("string"))[0];
            }

            // the 'max' y axis value in the xml isn't correct, so we'll calculate it ourselves...
            this.chartComponentConfig.chartConfig.yAxis[0].max = this._computeMaxYAxisValue(this.chartComponentConfig.chartData.series);

            this._configureYAxisIntervals();


            // Use number of ScheduleState values to show as a surrogate for with of the legend text.
            if(this.chartComponentConfig.chartData.series.length === 6) {
                this.chartComponentConfig.chartConfig.legend.itemStyle = { fontSize: '8px'};
            } else if(this.chartComponentConfig.chartData.series.length === 5) {
                this.chartComponentConfig.chartConfig.legend.itemStyle = { fontSize: '10px'};
            } // else it will default to 12px

            this.chartComponentConfig.chartConfig.xAxis.tickInterval = Math.floor(this.chartComponentConfig.chartData.series[0].data.length / 4);

            this.add(this.chartComponentConfig);
        },


        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        }
    });

})();

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart", {
        alias: "widget.statsbannerpiechart",
        extend: "Ext.Container",
        requires: [
            'Rally.ui.chart.Chart'
        ],
        mixins: {
            recordable: 'Rally.clientmetrics.ClientMetricsRecordable'
        },

        currentScope: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Pie',
        config: {
            context: null
        },

        initComponent: function() {
            this.callParent(arguments);

            if (this._storyStates === undefined) {
                Rally.data.ModelFactory.getModels({
                    types: ['UserStory', 'Defect', 'DefectSuite', 'TestSet'],
                    context: this.getContext(),
                    scope: this,
                    requester: this,
                    success: this._createStateMap
                });
            } else {
                this._loadArtifacts();
            }
        },

        _createStateMap: function(models) {
            var stateMap = ['Defined', 'In-Progress', 'Completed'],
                stateMapIndex = 0,
                storyStates = {};

            _.each(models.UserStory.getField('ScheduleState').getAllowedStringValues(), function(state) {
                if (state === stateMap[stateMapIndex + 1]) {
                    stateMapIndex++;
                }
                storyStates[state] = stateMap[stateMapIndex];
            });

            this._storyStates = storyStates;
            this._loadArtifacts();
        },

        _loadArtifacts: function() {
            this._chartData = [];
            this._childChartData = [];

            this.store = Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['User Story', 'Defect', 'Defect Suite', 'Test Set'],
                fetch: ['Defects', 'PlanEstimate', 'Requirement', 'FormattedID', 'Name', 'Blocked', 'BlockedReason', 'ScheduleState', 'State', 'Tasks', 'TestCases'],
                filters: [this.context.getTimeboxScope().getQueryFilter()],
                sorters: [
                    {property: 'ScheduleState'}
                ],
                context: this.context.getDataContext(),
                limit: Infinity,
                requester: this,
                autoLoad: true,
                listeners: {
                    load: this._loadChildCollections,
                    scope: this
                }
            });
        },

        _loadChildCollections: function() {
            var records = this.store.getRange();
            var promises = [];
            _.each(records, function(record) {
                if (record.get('Defects') && record.get('Defects').Count) {
                    promises.push(record.getCollection('Defects', {
                        fetch: ['FormattedID', 'Name', 'ScheduleState', 'Blocked', 'BlockedReason', 'Requirement', 'State']
                    }).load({
                        requester: this,
                        callback: function(defects) {
                            record.get('Defects').Results = defects;
                        }
                    }));
                }
                if (record.get('Tasks') && record.get('Tasks').Count) {
                    promises.push(record.getCollection('Tasks', {
                        fetch: ['FormattedID', 'Name', 'Blocked', 'BlockedReason', 'WorkProduct', 'State']
                    }).load(
                        {
                            requester: this,
                            callback: function(tasks) {
                                record.get('Tasks').Results = tasks;
                            }
                        }
                    ));
                }
                if (record.get('TestCases') && record.get('TestCases').Count){
                    promises.push(record.getCollection('TestCases', {
                        fetch: ['FormattedID', 'Name', 'Type', 'WorkProduct']
                    }).load({
                        requester: this,
                        callback: function(testCases){
                            record.get('TestCases').Results = testCases;
                            }
                        }
                    ));
                }
            });

            if (promises.length > 0) {
                Deft.Promise.all(promises).then({
                    success: this._onAllDataLoaded,
                    scope: this
                });
            } else {
                this._onAllDataLoaded();
            }
        },

        _onAllDataLoaded: function() {
            _.each(this.store.getRange(), function(record) {
                var defects = record.get('Defects');
                var defectCount = (defects && defects.Count) || 0;
                var tasks = record.get('Tasks');
                var taskCount = (tasks && tasks.Count) || 0;
                var testCases =  record.get('TestCases');
                var testCaseCount = (testCases && testCases.Count) || 0;
                var relatedCount = taskCount + defectCount + testCaseCount;
                var planEstimate = record.get('PlanEstimate') || 1;
                var pointSizeForChildren = (planEstimate / relatedCount) || 1;
                var nullPointString = 'No tasks or defects.';

                this._addPointForTopLevelItem(record, relatedCount);

                if (relatedCount === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                } else {
                    if (defects && defects.Results) {
                        _.each(defects.Results, function(defect) {
                            this._addPointForChildItem(defect, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (tasks && tasks.Results) {
                        _.each(tasks.Results, function(task) {
                            this._addPointForChildItem(task, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (testCases && testCases.Results) {
                        _.each(testCases.Results, function(testCase) {
                            this._addPointForChildItem(testCase, record.get('FormattedID'), pointSizeForChildren, record.get('ScheduleState'), record.get('Blocked'));
                        }, this);
                    }
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

            this.recordLoadEnd();
        },

        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;
            var height = this.height;
            var pieHeight = this.height * 0.9;

            return Ext.Object.merge({
                xtype: 'rallychart',
                loadMask: false,
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartData: {
                    series: [
                        {
                            type: 'pie',
                            name: 'Parents',
                            data: this._chartData,
                            size: pieHeight,
                            allowPointSelect: false,
                            dataLabels: {
                                enabled: false
                            }
                        },
                        {
                            type: 'pie',
                            name: 'Children',
                            data: this._childChartData,
                            size: pieHeight,
                            innerSize: 0.8 * pieHeight,
                            allowPointSelect: false,
                            dataLabels: { enabled: false }
                        }
                    ]
                },

                chartConfig: {
                    chart: {
                        type: 'pie',
                        height: height,
                        width: this.width,
                        spacingTop: 0,
                        spacingRight: 3,
                        spacingBottom: 0,
                        spacingLeft: 3,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    subtitle: {
                        useHTML: true,
                        text: '<table align="center" class="pie-chart-legend"><tr><td><span class="legend-swatch defined-sample-swatch"></span><span>Defined</td>' +
                              '<td><span class="legend-swatch in-progress-sample-swatch"></span>In-Progress</td>' +
                              '<td><span class="legend-swatch completed-sample-swatch"></span>Completed</td>' +
                              '<td><span class="legend-swatch blocked-sample-swatch"></span>Blocked</td></tr></table>',
                        verticalAlign: 'bottom',
                        floating: true,
                        x: -10,
                        y: -20
                    },
                    tooltip: {
                        formatter: this._formatTooltip,
                        useHTML: true
                    },
                    spacingTop: 0,
                    title: { text: null },
                    plotOptions: {
                        pie: {
                            cursor: 'pointer',
                            shadow: false,
                            center: ['50%', '45%'],
                            point: {
                                events: {
                                    click: function(event) {
                                        if (this.ref) {
                                            Rally.nav.Manager.showDetail(this.ref);
                                        }
                                    }
                                }
                            },
                            showInLegend: false
                        }
                    }
                }
            }, overrides || {});
        },

        _addPointForTopLevelItem: function(record, relatedCount) {
            var blocked = record.get('Blocked');
            var color = this._colorFromStatus(this._storyStates[record.get('ScheduleState')], blocked);
            var pointSize = record.get('PlanEstimate') || 1;

            this._chartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: record.get('ScheduleState'),
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: relatedCount > 0,
                relatedCount: relatedCount,
                ref: record.get('_ref'),
                parentFormattedID: null
            });
        },

        _colorFromStatus: function(state, blocked) { //refactor into css and classes, should get cleaner
            var progressColors = {
                'Defined': '#C0C0C0', // light gray
                'In-Progress': '#00A9E0', // cyan
                'Completed': '#8DC63F', // lime
                'Blocked': '#EE1C25' // red
            };
            var color =  progressColors[state];
            if (blocked) {
                color = progressColors.Blocked;
            }
            return color;
        },

        _addPointForChildItem: function(record, parentFormattedID, pointSize, parentState, isParentBlocked) {
            var blocked = record.get('Blocked');
            var state = record.get('ScheduleState') || record.get('State') || record.get('Type');
            var color = this._colorFromStatus(this._storyStates[parentState || state], blocked || isParentBlocked);

            this._childChartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: state,
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: false,
                relatedCount: 0,
                ref: record.get('_ref'),
                parentFormattedID: parentFormattedID
            });
        },

        _formatTooltip: function() {
            var relatedMessage = '';
            var blockedMessage = '';
            var artifactName = this.point.rallyName ? '<b>' + this.point.name + '</b>: ' + this.point.rallyName + '<br/>' : this.point.name;

            if (this.point.blocked) {
                blockedMessage = '<br/><b>Blocked</b>';
                if (this.point.blockedReason) {
                    blockedMessage += ': ' + this.point.blockedReason;
                }
            }

            if (this.point.series && this.point.series.name === 'Parents') {
                relatedMessage = (this.point.relatedCount) ? '<br/>Related Items: ' + this.point.relatedCount : '';
            }

            return '<div style="min-width:200px;white-space:normal">' + artifactName + this.point.status + relatedMessage + blockedMessage + '</div>';
        }
    });
})();

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.MinimalPieChart", {
        alias: "widget.statsbannerminimalpiechart",
        extend: "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart",

        _loadArtifacts: function() {
            this._chartData = [];
            this._childChartData = [];
            this._createDataPointsFromSummary();
        },

        _createDataPointsFromSummary: function() {
            _.each(this.store.getRange(), function(record){
                var summary = record.get('Summary');
                var totalChildItems = 0;
                var planEstimate = record.get('PlanEstimate') || 1;
                var nullPointString = 'No tasks or defects.';
                var testCases = record.get('TestCases');
                var keys, state, scheduleState, blocked, count;

                totalChildItems += summary.Defects ? summary.Defects.Count : 0;
                totalChildItems += summary.Tasks ? summary.Tasks.Count : 0;
                totalChildItems += testCases ? testCases.Count : 0;

                var pointSizeForChildren = (planEstimate / totalChildItems) || 1;

                this._addPointForTopLevelItem(record, totalChildItems);

                if (totalChildItems === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                }
                if (summary.Tasks && summary.Tasks.Count){
                    keys = _.keys(summary.Tasks['state+blocked']);
                    _.each(keys, function(key) {
                        state = key.split('+');
                        scheduleState =  state[0];
                        blocked = state[1] === 'true';
                        count = summary.Tasks['state+blocked'][key];
                        _.each(_.range(0, count), function(point) {
                            this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, scheduleState, blocked);
                        }, this);
                    }, this);
                }
                if (summary.Defects && summary.Defects.Count){
                    keys = _.keys(summary.Defects['schedulestate+blocked']);
                    _.each(keys, function(key) {
                        state = key.split('+');
                        scheduleState =  state[0];
                        blocked = state[1] === 'true';
                        count = summary.Defects['schedulestate+blocked'][key];
                        _.each(_.range(0, count), function(point) {
                            this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, scheduleState, blocked);
                        }, this);
                    }, this);
                }
                if (testCases && testCases.Count){
                    _.each(_.range(0,testCases.Count), function(point){
                        this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, record.get('ScheduleState'), record.get('Blocked'));
                    }, this);
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

        },

        _onAllDataLoaded: function() {
            _.each(this.store.getRange(), function(record) {
                var defects = record.get('Defects');
                var defectCount = (defects && defects.Count) || 0;
                var tasks = record.get('Tasks');
                var taskCount = (tasks && tasks.Count) || 0;
                var testCases =  record.get('TestCases');
                var testCaseCount = (testCases && testCases.Count) || 0;
                var relatedCount = taskCount + defectCount + testCaseCount;
                var planEstimate = record.get('PlanEstimate') || 1;
                var pointSizeForChildren = (planEstimate / relatedCount) || 1;
                var nullPointString = 'No tasks or defects.';

                this._addPointForTopLevelItem(record, relatedCount);

                if (relatedCount === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                } else {
                    if (defects && defects.Results) {
                        _.each(defects.Results, function(defect) {
                            this._addPointForChildItem(defect, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (tasks && tasks.Results) {
                        _.each(tasks.Results, function(task) {
                            this._addPointForChildItem(task, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (testCases && testCases.Results) {
                        _.each(testCases.Results, function(testCase) {
                            this._addPointForChildItem(testCase, record.get('FormattedID'), pointSizeForChildren, record.get('ScheduleState'), record.get('Blocked'));
                        }, this);
                    }
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

            this.recordLoadEnd();
        },

         _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;
            var height = this.height;
            return Ext.Object.merge({
                xtype: 'rallychart',
                loadMask: false,
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartData: {
                    series: [
                        {
                            type:'pie',
                            name: 'Parents',
                            data: this._chartData,
                            size: height,
                            allowPointSelect: false,
                            dataLabels: {
                                enabled: false
                            }
                        },
                        {
                            type:'pie',
                            name: 'Children',
                            data: this._childChartData,
                            size: height,
                            innerSize: 0.8 * height,
                            allowPointSelect: false,
                            dataLabels: { enabled: false }
                        }
                    ]
                },

                chartConfig: {
                    chart: {
                        type: 'pie',
                        height: height,
                        width: this.width,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    spacingTop: 0,
                    title: { text: null },
                    plotOptions: {
                        pie: {
                            shadow: false,
                            center: ['50%', '50%'],
                            point: {
                                events: {
                                    click: clickChartHandler
                                }
                            },
                            showInLegend: false
                        }
                    }
                }
            }, overrides || {});
        },

        _addPointForTopLevelItem: function(record, relatedCount) {
            var blocked = record.get('Blocked');
            var color = this._colorFromStatus(this._storyStates[record.get('ScheduleState')], blocked);
            var pointSize = record.get('PlanEstimate') || 1;

            this._chartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: record.get('ScheduleState'),
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: relatedCount > 0,
                relatedCount: relatedCount,
                ref: record.get('_ref'),
                parentFormattedID: null
            });
        },

        _addPointForChildItem: function(parentFormattedID, pointSize, state, blocked) {
            var color = this._colorFromStatus(this._storyStates[state], blocked);

            this._childChartData.push({
                y: pointSize,
                color: color,
                status: state,
                blocked: blocked,
                hasChildren: false,
                relatedCount: 0,
                parentFormattedID: parentFormattedID
            });
        }
      
    });
})();

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialogChartToggle', {
        requires:['Rally.ui.Button'],
        extend:'Ext.Container',
        alias:'widget.iterationprogressdialogcharttoggle',

        componentCls: 'iteration-progress-toggle-button-group',
        layout: 'hbox',
        border: 1,
        width: 106,
        activeButtonCls: 'rly-active',

        defaultType: 'rallybutton',

        config: {
            startingIndex: 0
        },

        items: [{
            cls: 'toggle rly-left pie-chart',
            iconCls: 'icon-pie',
            frame: false,
            toggleGroup: 'iterationprogressviewtoggle',
            style: {
                fontSize: '15px'
            },
            toolTipConfig: {
                html: 'Pie',
                anchor: 'top',
                hideDelay: 0
            },
            userAction:'IterationProgressApp - User clicked pie chart'
        }
//        {
//            cls: 'toggle center burndown',
//            iconCls: 'icon-bars',
//            frame: false,
//            toggleGroup: 'iterationprogressviewtoggle',
//            toolTipConfig: {
//                html: 'Burndown',
//                anchor: 'top',
//                hideDelay: 0
//            },
//            userAction:'IterationProgressApp - User clicked burndown'
//        },
//        {
//            cls: 'toggle rly-right cumulativeflow',
//            iconCls: 'icon-graph',
//            frame: false,
//            toggleGroup: 'iterationprogressviewtoggle',
//            toolTipConfig: {
//                html: 'Cumulative Flow',
//                anchor: 'top',
//                hideDelay: 0
//            },
//            userAction:'IterationProgressApp - User clicked CFD'
//        }
        ],

        initComponent: function(config) {
            this.initConfig(config);
            this.callParent(arguments);

            this.addEvents([
                /**
                 * @event toggle
                 * Fires when the toggle value is changed.
                 * @param {String} toggleState 'burndown' or 'cumulativeflow' or 'pie'.
                 */
                'toggle'
            ]);

            this.items.each(function(item) {
                item.on('click', this._onButtonClick, this);
            }, this);

            this.setCurrentItem(this.startingIndex);
        },

        _onButtonClick: function(btn) {
            var btnIndex = this.items.indexOf(btn);
            if (btnIndex !== this._activeIndex) {
                this._setActive(btn);
                this.fireEvent('toggle', this, btnIndex);
            }
        },

        _setActive: function(btn) {
            this.items.each(function(item, btnIndex) {
                if (item === btn) {
                    if (!item.hasCls(this.activeButtonCls.split(' ')[0])) {
                        item.addCls(this.activeButtonCls);
                        this._activeIndex = btnIndex;
                    }
                } else {
                    item.removeCls(this.activeButtonCls);
                }
            }, this);
        },

        setCurrentItem: function(itemIndex) {
            this._setActive(this.items.get(itemIndex));
        }
    });
})();


                (function(){

    var Ext = window.Ext4 || window.Ext;

    /**
    * shows burndown for timebox
    */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialog', {
        extend: 'Rally.ui.dialog.Dialog',
        alias:'widget.statsbanneriterationprogressdialog',
        requires: [
            'Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialogChartToggle',
//            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.BurndownChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.CumulativeFlowChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart',
            'Rally.ui.carousel.Carousel'
        ],
        config: {
            startingIndex: 0,
            autoShow: true,
            draggable: true,
            disableScroll: true,
            width: 820,
            height: 650,
            closable: true,
            constrain: true,
            store: null,
            context: null
        },
        layout: {
            type: 'vbox',
            align: 'center'
        },
        cls: 'iteration-progress-dialog',

        constructor: function (config){
            this.initConfig(config || {});
            this.callParent(arguments);
        },

        initComponent: function(){
            var chartWidth = 704;
            var chartHeight = 570;

            this.callParent(arguments);
            this.toggle = this.add({
                xtype: 'iterationprogressdialogcharttoggle',
                startingIndex: this.startingIndex,
                listeners: {
                    toggle: this._toggleButtonClick,
                    scope: this
                }
            });
            this.carousel = this.add({
                xtype: 'rallycarousel',
                showDots: false,
                enableAnimations: false,
                carouselItems: [
                    {
                        xtype: 'statsbannerpiechart',
                        width: chartWidth,
                        height: chartHeight,
                        context: this.context
                    }
//                    {
//                        xtype: 'statsbannerburndownchart',
//                        width: chartWidth,
//                        height: chartHeight,
//                        context: this.context,
//                        store: this.store
//                    },
//                    {
//                        xtype: 'statsbannercumulativeflowchart',
//                        width: chartWidth,
//                        height: chartHeight,
//                        context: this.context,
//                        store: this.store
//                    }
                ],
                startingIndex: this.startingIndex,
                listeners: {
                    carouselmove: {
                        fn: this._onCarouselMove,
                        scope: this
                    },
                    afterlayout: {
                        fn: this._afterLayout,
                        single: true,
                        scope: this
                    }
                }
            });
        },

        _toggleButtonClick: function(toggleBtnContainer, buttonIndex){
            this._setChart(buttonIndex);
        },

        _afterLayout: function(){
            Ext.defer(this._setChart, 10, this, [this.startingIndex]);
        },

        _setChart: function(chartIndex) {
            this.carousel.setCurrentItem(chartIndex);
            this.toggle.setCurrentItem(chartIndex);
            // need to bypass the setTitle method as it causes a relayout of the page messing up the carousel
            this.header.titleCmp.textEl.update(this.carousel.getCurrentItem().displayTitle);
        },

        _onCarouselMove: function(carousel){
            this._setChart(carousel.getCurrentItemIndex());
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows burndown for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.IterationProgress', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbanneriterationprogress',
        requires: [
            'Rally.ui.carousel.Carousel',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.BurndownChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.CumulativeFlowChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.MinimalPieChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart',
            'Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialog',
            'Ext.state.Manager'
        ],

        config: {
            context: null,
            store: null
        },

        currentChartDisplayed: 1,

        stateId: 'stats-banner-iteration-progress',
        stateful: true,

        clientMetrics: {
            method: '_onChartClick',
            description: 'opened IterationProgressDialog'
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title"></div>',
            '<div class="stat-metric">',
            '<div class="stat-carousel"></div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-pie"></span>',
            '<div class="stat-title"></div>',
            '</div>'
        ],

        initComponent: function () {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
            var boundClickHandler = Ext.bind(this._onChartClick, this);

            this.stateId = this.context.getScopedStateId(this.stateId);

            this.carouselItems = [
                {
                    xtype: 'statsbannerminimalpiechart',
                    width: 150,
                    height: 60,
                    minimalMode: true,
                    clickHandler: boundClickHandler,
                    context: this.context,
                    store: this.store
                }
//                {
//                    xtype: 'statsbannerburndownchart',
//                    width: 150,
//                    height: 63,
//                    minimalMode: true,
//                    clickHandler: boundClickHandler,
//                    context: this.context,
//                    store: this.store
//                },
//                {
//                    xtype: 'statsbannercumulativeflowchart',
//                    width: 150,
//                    height: 63,
//                    minimalMode: true,
//                    clickHandler: boundClickHandler,
//                    context: this.context,
//                    store: this.store
//                }
            ];

            _.each(this.carouselItems, function(carouselItem) {
                carouselItem.listeners = {
                    ready: this._onChartReady,
                    scope: this
                };
            }, this);

            this._pendingChartReadies = this.carouselItems.length;

            if (!this.expanded) {
                this.fireEvent('ready', this);
            } else {
                this.onDataChanged();
            }
        },

        expand: function() {
            this.callParent();
            // Carousel was updated while hidden so it needs to die
            // and we create a new one since it can't lay itself out
            if (!this.carousel || this.carousel.getWidth() === 0) {
                this.onDataChanged();
            }
        },

        _onChartReady: function() {
            this._pendingChartReadies -= 1;
            if (this._pendingChartReadies === 0) {
                this.fireEvent('ready', this);
            }
        },

        _onChartClick: function() {
            var currentIndex = this.carousel.getCurrentItemIndex();
            Ext.create('Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialog', {
                startingIndex: currentIndex,
                store: this.store,
                context: this.context
            });
        },

        _cleanupCarousel: function () {
            if (this.carousel) {
                this.carousel.destroy();
                delete this.carousel;
            }
        },

        onDestroy: function () {
            this._cleanupCarousel();
            this.callParent(arguments);
        },

        onRender: function() {
            this.callParent(arguments);
            if (!this.getContext().getTimeboxScope().getRecord()) {
                this._addPlaceholder();
            }
        },

        applyState: function (state) {
            if (state){
                if (state.currentChartDisplayed > this.carouselItems.length -1 || state.currentChartDisplayed < 0) {
                    this.currentChartDisplayed = 1;
                } else {
                    this.currentChartDisplayed = state.currentChartDisplayed;
                }
            }
        },

        getState: function(){
            return {
                currentChartDisplayed: this.currentChartDisplayed
            };
        },

        onDataChanged: function() {
            this._cleanupCarousel();

            var addCarousel = _.bind(function() {
                if (this.getContext().getTimeboxScope().getRecord()) {
                    this.update();

                    this.createCarousel();
                } else {
                    this._addPlaceholder();
                }
            }, this);
            if (this.expanded) {
                if (this.rendered) {
                    addCarousel();
                } else {
                    this.on('afterrender', addCarousel);
                }
            }
        },

        createCarousel: function() {
            this.carousel = Ext.create('Rally.ui.carousel.Carousel', {
                showHeader: false,
                showDots: true,
                smallDots: true,
                renderTo: this.getEl().down('.stat-carousel'),
                height: 75,
                layout: {
                    type: 'vbox',
                    align: 'center'
                },
                listeners: {
                    currentitemset: this._updateTitle,
                    carouselmove: this._updateTitle,
                    scope: this
                },
                carouselItems: this.carouselItems
            });

            if (!Ext.isIE8m){
                // if such next line runs IE8 or < goes boom! WOW!
                this.carousel.setCurrentItem(this.currentChartDisplayed);
            }

            this.carousel.on('carouselmove', this._chartShownChanged, this);
        },

        _updateTitle: function(carousel){
            _.each(this.getEl().query('.stat-title'), function(el){
                Ext.fly(el).update(carousel.getCurrentItem().displayTitle);
            }, this);
        },

        _chartShownChanged: function(){
            var chartShown = _.findIndex(this.carouselItems, {xtype: this.carousel.getCurrentItem().xtype});
            this.currentChartDisplayed = chartShown || 0;
            this.saveState();
        },

        _addPlaceholder: function() {
            this.update();

            if (this.expanded) {
                this.carousel = Ext.create('Ext.Container', {
                    renderTo: this.getEl().down('.stat-carousel'),
                    html: 'no iteration data'
                });
            }
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows collapse/expand toggle for stats banner
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.CollapseExpand', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannercollapseexpand',
        requires: [],
        mixins: [
            'Rally.clientmetrics.ClientMetricsRecordable'
        ],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="toggle-icon icon-collapse-row"></div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="toggle-icon icon-expand-row"></div>',
            '</div>'
        ],

        componentCls: 'collapse-expand',

        bubbleEvents: ['collapse', 'expand'],

        afterRender: function() {
            this.callParent(arguments);
            this.parentComponent.getEl().on('click', this._onCollapseExpandClick, this);
            this.fireEvent('ready', this);
        },

        _onCollapseExpandClick: function (event, target) {
            if (this.expanded) {
                if (target.getAttribute('class').indexOf('toggle-icon') > -1 || Ext.get(target).down('div .toggle-icon')) {
                    this.fireEvent('collapse', this);
                }
            } else {
                this.fireEvent('expand', this);
            }
        },

        expand: function() {
            this.recordAction({
                description: 'Expand statsbanner'
            });
            this.callParent(arguments);
            this.doComponentLayout();
        },

        collapse: function() {
            this.recordAction({
                description: 'Collapse statsbanner'
            });
            this.callParent(arguments);
            this.doComponentLayout();
        }
    });
})();
                var bannerme;
(function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Allows user to see stats for a timebox in a horizontal bar format
     */
    Ext.define('Rally.apps.iterationtrackingboard.StatsBanner', {
        extend: 'Ext.Container',
        alias:'widget.statsbanner',
        requires: [
            'Rally.Message',
            'Rally.apps.iterationtrackingboard.statsbanner.PlannedVelocity',
            'Rally.apps.iterationtrackingboard.statsbanner.TimeboxEnd',
            'Rally.apps.iterationtrackingboard.statsbanner.Defects',
            'Rally.apps.iterationtrackingboard.statsbanner.Accepted',
            'Rally.apps.iterationtrackingboard.statsbanner.Tasks',
            'Rally.apps.iterationtrackingboard.statsbanner.IterationProgress',
            'Rally.apps.iterationtrackingboard.statsbanner.CollapseExpand'
        ],
        mixins: [
            'Rally.Messageable',
            'Rally.clientmetrics.ClientMetricsRecordable'
        ],
        cls: 'stats-banner',
        layout: 'hbox',
        border: 0,
        width: '100%',
        stateful: true,
        stateEvents: ['expand', 'collapse'],
        featureStore: undefined,

        config: {
            context: null,
            expanded: false,
            optimizeLayouts: false
        },

        items: [
            {xtype: 'statsbannerplannedvelocity'},
            {xtype: 'statsbannertimeboxend'},
            {xtype: 'statsbanneraccepted'},
            {xtype: 'statsbannerdefects'},
            {xtype: 'statsbannertasks'},
            {xtype: 'statsbanneriterationprogress', flex: 2},
            {xtype: 'statsbannercollapseexpand', flex: 0}
        ],

        constructor: function(config) {
            if (config.optimizeLayouts) {
                config._isLayoutRoot = true;
            }
            this.callParent(arguments);
        },

        initComponent: function () {
            this.recordLoadBegin({
                description: 'initializing'
            });

            this.addEvents(
                /**
                 * @event
                 * Fires when expand is clicked
                 */
                'expand',
                /**
                 * @event
                 * Fires when collapse is clicked
                 */
                'collapse'
            );

            this._readyCount = 0;

            this.stateId = this.context.getScopedStateId('stats-banner');

            this.subscribe(this, Rally.Message.objectDestroy, this._update, this);
            this.subscribe(this, Rally.Message.objectCreate, this._update, this);
            this.subscribe(this, Rally.Message.objectUpdate, this._update, this);
            this.subscribe(this, Rally.Message.bulkUpdate, this._update, this);
            this.subscribe(this, Rally.Message.bulkImport, this._update, this);            

            this.store = Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['User Story', 'Defect', 'PortfolioItem/Feature'],
                fetch: ['Defects:summary[State;ScheduleState+Blocked]', 'PlanEstimate', 'Requirement', 
                        'FormattedID', 'Name', 'ScheduleState', 'State'],
                useShallowFetch: true,
                sorters: [
                    {property: 'ScheduleState'},
                    {property: 'State'}
                ],
                filters: [this.context.getTimeboxScope().getQueryFilter()],
                context: this.context.getDataContext(),
                limit: Infinity,
                requester: this
            });
            
            this.featureStore =  Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['PortfolioItem/Feature'],
                fetch: ['State'],
                useShallowFetch: true,
                sorters: [
                    {property: 'State'}
                ],
                filters: [this.context.getTimeboxScope().getQueryFilter()],
                context: this.context.getDataContext(),
                limit: Infinity,
                requester: this
            }); 

            //need to configure the items at the instance level, not the class level (i.e. don't use the 'defaults' config)
            this.items = this._configureItems(this.items);
//            this.items[0].store = this.featureStore;

            this.on('expand', this._onExpand, this);
            this.on('collapse', this._onCollapse, this);
            this.callParent(arguments);

            this._update();
        },

        onRender: function () {
            if (this.expanded) {
                this.removeCls('collapsed');
            } else {
                this.addCls('collapsed');
            }
            this._setExpandedOnChildItems();
            this.callParent(arguments);
        },

        applyState: function (state) {
            if (Ext.isDefined(state.expanded)) {
                this.setExpanded(state.expanded);
            }
            this._setExpandedOnChildItems();
        },

        getState: function () {
            return {
                expanded: this.expanded
            };
        },

        _setExpandedOnChildItems: function () {
            _.each(this.items.getRange(), function(item) {
                item.setExpanded(this.expanded);
            }, this);
        },

        _getItemDefaults: function () {
            return {
                flex: 1,
                context: this.context,
                store: this.store,
                expanded: this.expanded,
                parentComponent: this,
                listeners: {
                    ready: this._onReady,
                    scope: this
                }
            };
        },

        _onReady: function () {
            this._readyCount = this._readyCount + 1;
            if (this._readyCount === this.items.getCount()) {
                this.recordComponentReady();
                this._readyCount = 0;
                this._recordLoadEnd();
            }
        },

        _onCollapse: function () {
            this.addCls('collapsed');
            this.setExpanded(false);

            _.invoke(this.items.getRange(), 'collapse');
        },

        _onExpand: function () {
            this.removeCls('collapsed');
            this.setExpanded(true);

            _.invoke(this.items.getRange(), 'expand');
        },

        _hasTimebox: function () {
            return !!this.context.getTimeboxScope().getRecord();
        },

        _configureItems: function (items) {
            var defaults = this._getItemDefaults();
            return _.map(items, function(item) {
                return _.defaults(_.cloneDeep(item), defaults);
            });
        },

        _recordLoadEnd: function () {
            this.recordLoadEnd();
        },

        _update: function () {
            if(this._hasTimebox()) {
                this.store.load();
//                this.featureStore.load();
            } else {
                this._recordLoadEnd();
            }
        }
    });
})();

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownSettings", {
        requires: [
            "Rally.apps.charts.settings.ChartDisplayTypePicker",
            "Rally.apps.charts.settings.DataTypePicker",
            "Rally.apps.charts.settings.TimeboxPicker",
            "Rally.ui.CheckboxField"
        ],

        config: {
            app: undefined
        },
        
        constructor: function (config) {
            this.mergeConfig(config);
        },

        _buildSettingsComponent: function (type, label, name) {
            var self = this;

            var componentAdded = function (cmp) {
                this.settingsParent = this.settingsParent || self;
            };

            var settings = {
                xtype: type,
                label: label,
                listeners: {
                    added: componentAdded
                }
            };
            if (name) {
                settings.name = name;
                settings.cls = "settings-" + name;
            }
            return settings;
        },

        _isOnScopedDashboard: function() {
            return this.app.isOnScopedDashboard() && !!this.app.context.getTimeboxScope();
        },

        getFields: function() {
            var dataTypePicker = this._buildSettingsComponent("chartdatatypepicker", "Data Type"),
                displayPicker = this._buildSettingsComponent("chartdisplaytypepicker", "Chart Type"),
                timeboxPicker = this._buildSettingsComponent("charttimeboxpicker", "Level"),
                labelNameVisible = this._buildSettingsComponent("rallycheckboxfield", "Show Iteration Labels", 'showLabels');
            
            if(this._isOnScopedDashboard()) {
                return [dataTypePicker, displayPicker, labelNameVisible];
            } else {
                return [timeboxPicker, dataTypePicker, displayPicker, labelNameVisible];
            }
        }
        

    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownChart", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        defaultChartComponentConfig: function() {
            return {
                xtype: "rallychart",
                itemId: "burndownchart",

                aggregationErrorMessage: "No data to display. Check the data type setting for displaying data based on count versus plan estimate.",

                storeType: "Rally.data.lookback.SnapshotStore",
                storeConfig: {
                    find: {
                        "_TypeHierarchy": { '$in' : [ -51038, -51006 ] },
                        "Children": null
                    },
                    fetch: ["ScheduleState", "PlanEstimate", "ObjectId", "_ValidFrom", "_ValidTo"],
                    hydrate: ["ScheduleState"],
                    sort: {
                        "_ValidFrom": 1
                    },
                    compress: true,
                    useHttpPost: true
                },

                calculatorType: "Rally.apps.charts.burndown.BurnDownCalculator",
                calculatorConfig: {
                    timeZone: "GMT",
                    completedScheduleStateNames: null, // defaults hide problems
                    enableProjections: true,
                    timebox: null

                    //chartAggregationType: ''
                },

                chartColors: ["#005eb8", "#8dc63f", "#666666", "#c0c0c0"],

                chartConfig: {
                    chart: {
                        zoomType: "xy"
                    },
                    xAxis: {
                        categories: [],
                        tickmarkPlacement: "on",
                        tickInterval: 7,
                        title: {
                            text: "Days",
                            margin: 12
                        },
                        maxPadding: 0.25,
                        labels: {
                            x: 0,
                            y: 20,
                            overflow: "justify"
                        }
                    },
                    yAxis: [],
                    tooltip: {
                        formatter: function () {
                            var floatValue = parseFloat(this.y),
                                value = this.y;

                            if (!isNaN(floatValue)) {
                                value = Math.floor(floatValue * 100) / 100;
                            }

                            return "" + this.x + "<br />" + this.series.name + ": " + value;
                        }
                    },
                    plotOptions: {
                        series: {
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: true
                                    }
                                }
                            },
                            connectNulls: true
                        },
                        column: {
                            pointPadding: 0,
                            borderWidth: 0,
                            stacking: null,
                            shadow: false
                        }
                    }
                }
            };

        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.charts.burndown.BurnDownApp', {
        extend: 'Rally.app.TimeboxScopedApp',

        settingsScope: 'project',
        scopeType: 'release',

        requires: [
            'Rally.apps.charts.burndown.BurnDownSettings',
            'Rally.data.wsapi.Store',
            'Rally.util.Help',
            'Rally.ui.combobox.IterationComboBox',
            'Rally.ui.combobox.ReleaseComboBox',
            'Rally.apps.charts.IntegrationHeaders',
            'Rally.apps.charts.burndown.BurnDownChart',
            'Rally.apps.iterationtrackingboard.StatsBanner'
        ],

        mixins: [
            'Rally.apps.charts.DateMixin'
        ],

        cls: 'burndown-app',

        items: [
            {
                xtype: 'container',
                itemId: 'header',
                cls: 'header'
            }
        ],

        help: {
            id: 278
        },

        scopeObject: undefined,

        customScheduleStates: null, // defaults hide problems

        config: {
            defaultSettings: {
                showLabels: true,
                chartAggregationType: undefined,
                chartDisplayType: undefined,
                chartTimebox: 'release',
                title: ''
            }
        },

        chartComponentConfig: undefined,

        getSettingsFields: function () {
            this.chartSettings = this.chartSettings || Ext.create('Rally.apps.charts.burndown.BurnDownSettings', {
                app: this
            });

            return this.chartSettings.getFields();
        },

        onScopeChange: function (scope) {
            if (!this.ignoreOnScopeChange) {
                this._rebuildChartForScope(scope.getRecord().get('_ref'));

            }
        },

        launch: function () {
            if (this._settingsInvalid()) {
                if (this.owner) {
                    this.owner.showSettings();
                    return;
                }
            }
            this.customScheduleStates = null;
            this.chartComponentConfig = Ext.create('Rally.apps.charts.burndown.BurnDownChart', this).defaultChartComponentConfig();

            Ext.create('Rally.apps.charts.IntegrationHeaders',this).applyTo(this.chartComponentConfig.storeConfig);

            this._addHelpComponent();
            this._loadUserStoryModel();
            this._saveScopeType();
            this.callParent(arguments);

            if (!this.isOnScopedDashboard()) {
                this.ignoreOnScopeChange = true;
                this._getScopePicker().on('ready', this._loadScopePreference, this, {single: true});
            }
        },

        _addStatsBanner: function() {
            this.remove('statsBanner');
            this.add({
              xtype: 'statsbanner',
              itemId: 'statsBanner',
              context: this.getContext(),
              margin: '0 0 5px 0',
              listeners: {
                resize: this._resizeGridBoardToFillSpace,
                scope: this
              }
            });
        },
        
        _resizeGridBoardToFillSpace: function() {
            if(this.gridboard) {
              this.gridboard.setHeight(this.getAvailableGridBoardHeight());
            }
          },

          
        getAvailableGridBoardHeight: function() {
            var height = this.getHeight();
            if(this.down('#statsBanner').rendered) {
              height -= this.down('#statsBanner').getHeight();
            }
            return height;
        },

        
        
        _addHelpComponent: function () {
            this.down('#header').add(this._buildHelpComponent());
        },

        _buildHelpComponent: function () {
            return Ext.create('Ext.Component', {
                renderTpl: Rally.util.Help.getIcon({
                    cls: Rally.util.Test.toBrowserTestCssClass(this.help.cls),
                    id: this.help.id
                })
            });
        },

        _rebuildChartForScope: function(scopeRef) {
            this._destroyChart();

            this._saveScopePreference(scopeRef);
            this._loadScopeObject(scopeRef);
            this._addStatsBanner();
        },

        _destroyChart: function () {
            this.remove('burndownchart');
        },

        _saveScopePreference: function (scopeRef) {
            if (!this.isOnScopedDashboard()) {
                var settings = {};
                settings[this._getScopeType()] = scopeRef;

                Rally.data.PreferenceManager.update({
                    appID: this.getContext().get('appID'),
                    settings: settings,
                    scope: this
                });
            }
        },

        _loadScopePreference: function (picker) {
            Rally.data.PreferenceManager.load({
                appID: this.getContext().get('appID'),
                success: function (preferences) {
                    var scopeRef = preferences[this._getScopeType()];
                    if (!scopeRef || scopeRef === 'undefined') {
                        var pickerRecord = picker.getRecord();
                        if (pickerRecord) {
                            scopeRef = pickerRecord.get('_ref');
                            this._saveScopePreference(scopeRef);
                        }
                    }
                    this.ignoreOnScopeChange = false;

                    if (scopeRef && scopeRef !== 'undefined') {
                        this._setScopeValue(scopeRef);
                        scopeRef = this._getScopePicker().getValue();
                        if (scopeRef) {
                            this._rebuildChartForScope(scopeRef);
                        }
                    }
                },
                scope: this
            });
        },

        _setScopeValue: function (scopeRef) {
            this._getScopePicker().setValue(scopeRef);
        },

        _loadTimeboxes: function() {
            Ext.create('Rally.data.wsapi.Store', {
                model: this.scopeObject._type,
                filters: [
                    {
                        property: 'Name',
                        operator: '=',
                        value: this.scopeObject.Name
                    },
                    {
                        property: this._getScopeObjectStartDateName(),
                        operator: '=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                    },
                    {
                        property: this._getScopeObjectEndDateName(),
                        operator: '=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                    }
                ],
                context: this.getContext().getDataContext(),
                fetch: ['ObjectID'],
                limit: Infinity,
                autoLoad: true,
                listeners: {
                    load: function (store, records) {
                        this._getTimeboxesInScope(store, records);
                    },
                    scope: this
                }
            });
        },

        _onScopeObjectLoaded: function (record) {
            this._setScopeFromData(record);

            this._updateChartTitle();
            this._updateYAxis();

            this._addDateBounds();
            this._addAggregationTypeToCalculator();
            this._loadTimeboxes();
        },

        _renderChartBasedOnType: function () {
            if (this._getScopeType() === 'release') {
                this._fetchIterations();
            } else {
                if ( this.customScheduleStates === null) { // wait until we get the schedule states
                    this.deferredAddChart = this._addChart;
                } else {
                    this._addChart();
                }
            }
        },

        _setScopeFromData: function (record) {
            this.scopeObject = record.data;
        },

        _getTimeboxesInScope: function (store, records) {
            var storeConfig = this.chartComponentConfig.storeConfig;
            var type = Ext.String.capitalize(this._getScopeType());
            var oids = [];
            var i;

            this.timeboxes = store.getItems();
            this._clearStoreConfig(storeConfig);

            for (i = 0; i < this.timeboxes.length; i++) {
                oids.push(this.timeboxes[i].ObjectID);
            }
            storeConfig.find[type] = { '$in' : oids };

            this._renderChartBasedOnType();

        },

        _addChartWithIterationLines: function () {
            this._addChart();
            this.down('rallychart').on('snapshotsAggregated', this._addIterationLines, this);
        },

        _onIterationsLoaded: function (store) {
            this.iterations = store.getItems();

            if ( this.customScheduleStates === null) {
                this.deferredAddChart = this._addChartWithIterationLines;
            } else {
                this._addChartWithIterationLines();
            }
        },

        _addDateBounds: function () {
            this._addDateBoundsToQuery();
            this._addDateBoundsToCalculator();
        },

        _addDateBoundsToQuery: function () {

        },

        _getNow: function() {
            return new Date();
        },

        _addDateBoundsToCalculator: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            var endDate = this._getScopeObjectEndDate();
            var now = this._getNow();
            calcConfig.startDate = Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true);
            if(now > this._getScopeObjectStartDate() && now < this._getScopeObjectEndDate()) {
                endDate = now;
            }
            calcConfig.endDate = Rally.util.DateTime.toIsoString(endDate, true);
            // S53625: If the time-box has ended, disable the projection line
            if (now > this._getScopeObjectEndDate()) {
                calcConfig.enableProjections = false;
            } else {
                calcConfig.enableProjections = true;
            }
            // add scopeEndDate, which may or may not be the same as endDate
            calcConfig.scopeEndDate = this._getScopeObjectEndDate();
        },

        _addAggregationTypeToCalculator: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            calcConfig.chartAggregationType = this.getSetting('chartAggregationType');
        },

        _updateCompletedScheduleStates: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            calcConfig.completedScheduleStateNames = this.customScheduleStates;
        },

        _loadScopeObject: function (scopeRef) {
            Rally.data.ModelFactory.getModel({
                type: this._getScopeType(),

                context: {
                    workspace: this.getContext().getWorkspaceRef(),
                    project: null
                },
                success: function(model) {
                    model.load(Rally.util.Ref.getOidFromRef(scopeRef), {
                        success: function(record) {
                            this._onScopeObjectLoaded(record);
                        },
                        scope: this
                    });
                },
                scope: this
            });
        },

        _fetchIterations: function () {
            var store = Ext.create('Rally.data.wsapi.Store', {
                model: Ext.identityFn('Iteration'),
                filters: [
                    {
                        property: 'StartDate',
                        operator: '>=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                    },
                    {
                        property: 'EndDate',
                        operator: '<=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                    }
                ],
                context: {
                    workspace: this.getContext().getWorkspaceRef(),
                    project: this.getContext().getProjectRef()
                },
                fetch: ['Name','StartDate','EndDate'],
                limit: Infinity
            });

            store.on('load', this._onIterationsLoaded, this);
            store.load();
        },

        _areIterationsEqual: function (iteration1, iteration2) {
            return iteration1.Name === iteration2.Name &&
                   iteration1.StartDate === iteration2.StartDate &&
                   iteration1.EndDate === iteration2.EndDate;
        },

        _addIterationLines: function (chart) {
            var axis = chart.chartConfig.xAxis;
            var categories = chart.chartData.categories;
            var i, j;
            var uniqueIterations = [];
            var unique;

            axis.plotLines = [];
            axis.plotBands = [];

            for (i = 0; i < this.iterations.length; i++) {
                unique = true;
                for (j = 0; j < uniqueIterations.length; j++) {
                    if(this._areIterationsEqual(uniqueIterations[j], this.iterations[i])) {
                        unique = false;
                        break;
                    }
                }
                if(unique === true) {
                    uniqueIterations.push(this.iterations[i]);
                }
            }

            for (i = 0; i < uniqueIterations.length; i++) {
                axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[i], false));
                axis.plotBands.push(this._getPlotBand(categories, uniqueIterations[i], i % 2 !== 0));
            }

            if (uniqueIterations.length > 0) {
                axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[uniqueIterations.length - 1], true));
            }
        },
        _buildLabelText: function(iteration) {
            var labelSetting = this.getSetting("showLabels");

            var text = '';
            if (labelSetting) {
                text = iteration.Name || '';
            }
            return text;
        },

        _getPlotBand: function (categories, iteration, shouldColorize) {
            var startDate = this.dateStringToObject(iteration.StartDate);
            var endDate = this.dateStringToObject(iteration.EndDate);

            var label =   {
                    text: this._buildLabelText( iteration ),
                    align: 'center',
                    rotation: 0,
                    y: -7
            };

            return {
                color: shouldColorize ? '#F2FAFF' : '#FFFFFF',
                from: this._getNearestWorkday(categories, startDate),
                to: this._getNearestWorkday(categories, endDate),

                label: label
            };
        },

        _getNearestWorkday: function(categories, date) {
            var dateStr = Ext.Date.format(date, 'Y-m-d');
            var index = categories.indexOf(dateStr);
            if(index === -1) {
                var workdays = this._getWorkspaceConfiguredWorkdays();
                if(workdays.length < 1) {
                    return -1;
                }
                // date not in categories (probably) means it falls on a non-workday...back up to the next previous workday
                while (workdays.indexOf(Ext.Date.format(date, 'l')) === -1 && date > this._getScopeObjectStartDate()) {
                    date = Ext.Date.add(date, Ext.Date.DAY, -1);
                    dateStr = Ext.Date.format(date, 'Y-m-d');
                    index = categories.indexOf(dateStr);
                }
            }
            return index;
        },

        _getPlotLine: function (categories, iteration, lastLine) {
            var dateObj;
            var dateIndex;

            if (lastLine) {
                dateObj = this.dateStringToObject(iteration.EndDate);
            } else {
                dateObj = this.dateStringToObject(iteration.StartDate);
            }

            dateIndex = this._getNearestWorkday(categories, dateObj);

            return {
                color: '#BBBBBB',
                dashStyle: 'ShortDash',
                width: 2,
                zIndex: 3,
                value: dateIndex
            };
        },

        _addChart: function () {
            this._updateCompletedScheduleStates();
            this._updateChartConfigDateFormat();
            this._updateChartConfigWorkdays();
            var chartComponentConfig = Ext.Object.merge({}, this.chartComponentConfig);

            this.add(chartComponentConfig);
            this.down('rallychart').on('snapshotsAggregated', this._onSnapshotDataReady, this);
        },

        _onSnapshotDataReady: function (chart) {
            this._updateDisplayType(chart);
            this._updateXAxis(chart);
        },

        _updateDisplayType: function (chart) {
            var series = chart.chartData.series;
            var displayType = this.getSetting('chartDisplayType');
            var i;

            for (i = 0; i < series.length; i++) {
                if (this._seriesFollowsDisplayType(series[i])) {
                    series[i].type = displayType;
                }
            }
        },

        _seriesFollowsDisplayType: function (series) {
            return series.name.indexOf('Ideal') === -1 && series.name.indexOf('Prediction') === -1;
        },

        _updateYAxis: function () {
            this._updateYAxisTitle();
            this._updateYAxisConfig();
        },

        _updateYAxisTitle: function () {
            var chartConfig = this.chartComponentConfig.chartConfig;
            chartConfig.yAxis = [
                {}
            ];
            chartConfig.yAxis[0].title = {
                text: this._getAxisTitleBasedOnAggregationType()
            };
        },

        _updateYAxisConfig: function () {
            var axis = this.chartComponentConfig.chartConfig.yAxis[0];
            axis.min = 0;
            axis.labels = {
                x: -5,
                y: 4
            };
        },

        _updateXAxis: function (chart) {
            if(this.container.dom.offsetWidth < 1000) {
                chart.chartConfig.xAxis.labels.staggerLines = 2;
            }
            chart.chartConfig.xAxis.labels.step = Math.round( chart.chartData.categories.length / 100 );
            chart.chartConfig.xAxis.tickInterval = this._configureChartTicks(chart.chartData.categories.length);
        },

        _configureChartTicks: function (days) {
            var pixelTickWidth = 125,
                appWidth = this.getWidth(),
                ticks = Math.floor(appWidth / pixelTickWidth);

            return Math.ceil(days / ticks);
        },

        _getAxisTitleBasedOnAggregationType: function () {
            var aggregationType = this.getSetting('chartAggregationType');
            if (aggregationType === 'storycount') {
                return 'Count';
            } else {
                return 'Points';
            }
        },

        _updateChartConfigDateFormat: function () {
            var self = this;

            this.chartComponentConfig.chartConfig.xAxis.labels.formatter = function () {
                return self._formatDate(self.dateStringToObject(this.value));
            };
        },

        _updateChartConfigWorkdays: function () {
            this.chartComponentConfig.calculatorConfig.workDays = this._getWorkspaceConfiguredWorkdays().split(',');
        },

        _parseRallyDateFormatToHighchartsDateFormat: function () {
            var dateFormat = this._getUserConfiguredDateFormat() || this._getWorkspaceConfiguredDateFormat();

            for (var i = 0; i < this.dateFormatters.length; i++) {
                dateFormat = dateFormat.replace(this.dateFormatters[i].key, this.dateFormatters[i].value);
            }

            return dateFormat;
        },

        _formatDate: function (date) {
            if (!this.dateFormat) {
                this.dateFormat = this._parseRallyDateFormatToHighchartsDateFormat();
            }

            return Highcharts.dateFormat(this.dateFormat, date.getTime());
        },

        _getUserConfiguredDateFormat: function () {
            return this.getContext().getUser().UserProfile.DateFormat;
        },

        _getWorkspaceConfiguredDateFormat: function () {
            return this.getContext().getWorkspace().WorkspaceConfiguration.DateFormat;
        },

        _getWorkspaceConfiguredWorkdays: function () {
            return this.getContext().getWorkspace().WorkspaceConfiguration.WorkDays;
        },

        _updateChartTitle: function () {
            this.chartComponentConfig.chartConfig.title = this._buildChartTitle();
        },

        _buildChartTitle: function () {
            var widthPerCharacter = 10;
            var totalCharacters = Math.floor(this.getWidth() / widthPerCharacter);
            var title = this._getDefaultTitle();
            var align = 'center';

            if (this.scopeObject) {
                title = this.scopeObject.Name;
            }

            if (totalCharacters < title.length) {
                title = title.substring(0, totalCharacters) + '...';
                align = 'left';
            }

            return {
                text: title,
                align: align,
                margin: 30
            };
        },

        _getDefaultTitle: function () {
            return Ext.String.capitalize(this._getScopeType());
        },

        _settingsInvalid: function () {
            var chartAggregationType = this.getSetting('chartAggregationType'),
                chartDisplayType = this.getSetting('chartDisplayType'),
                chartTimebox = this.getSetting('chartTimebox');

            var invalid = function (value) {
                return !value || value === 'undefined';
            };

            return invalid(chartAggregationType) || invalid(chartDisplayType) ||
                this._chartTimeboxInvalid(chartTimebox);
        },

        _chartTimeboxInvalid: function (chartTimebox) {
            if (this.context.getTimeboxScope()) {
                return false;
            }

            return !chartTimebox || chartTimebox === 'undefined';
        },

        _saveScopeType: function () {
            this.scopeType = this._getScopeType();
        },

        _getScopeType: function () {
            if (this.isOnScopedDashboard()) {
                return this._getDashboardScopeType();
            } else {
                return this._getSavedScopeType();
            }
        },

        _getDashboardScopeType: function () {
            return this.getContext().getTimeboxScope().getType();
        },

        _getSavedScopeType: function () {
            return this.getSetting('chartTimebox');
        },

        _getScopePicker: function () {
            if (this.isOnScopedDashboard()) {
                return this.getContext().getTimeboxScope();
            } else {
                return this.down('rally' + this._getScopeType() + 'combobox');
            }
        },

        _getScopeObjectStartDateName: function () {
            if (!this.scopeObject) {
                return '';
            } else if (this.scopeObject._type === 'release') {
                return 'ReleaseStartDate';
            } else {
                return 'StartDate';
            }
        },

        _getScopeObjectEndDateName: function () {
            if (!this.scopeObject) {
                return '';
            } else if (this.scopeObject._type === 'release') {
                return 'ReleaseDate';
            } else {
                return 'EndDate';
            }
        },

        _getScopeObjectStartDate: function () {
            if (!this.scopeObject) {
                return this._getNow();
            } else if (this.scopeObject._type === 'release') {
                return this.scopeObject.ReleaseStartDate;
            } else {
                return this.scopeObject.StartDate;
            }
        },

        _getScopeObjectEndDate: function () {
            if (!this.scopeObject) {
                return this._getNow();
            } else if (this.scopeObject._type === 'release') {
                return this.scopeObject.ReleaseDate;
            } else {
                return this.scopeObject.EndDate;
            }
        },

        _clearStoreConfig: function (storeConfig) {
            if (storeConfig.find.hasOwnProperty('Release')) {
                delete storeConfig.find.Release;
            }

            if (storeConfig.find.hasOwnProperty('Iteration')) {
                delete storeConfig.find.Iteration;
            }
        },

        _loadUserStoryModel: function() {
            Rally.data.ModelFactory.getModel({
                type: "UserStory",
                context: this._getContext(),
                success: function(model) {
                    this._getScheduleStateValues(model);
                },
                scope: this
            });
        },

        _getContext: function() {
            return {
                workspace: this.context.getWorkspaceRef(),
                project: null
            };
        },

        _getScheduleStateValues: function (model) {
            var scheduleStates = model.getField('ScheduleState').getAllowedStringValues();

            this.customScheduleStates = scheduleStates.slice(scheduleStates.indexOf('Accepted'), scheduleStates.length);

            if (this.deferredAddChart) {
                this.deferredAddChart.call(this);
            }
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownCalculator", {
        extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",
        mixins: [
            "Rally.apps.charts.DateMixin"
        ],

        getDerivedFieldsOnInput: function () {
            var completedStates = this.config.completedScheduleStateNames,
                aggregationType = this.config.chartAggregationType;

            return [
                {
                    "as": "RemainingPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if(completedStates.indexOf(ss) < 0) {
                            if(aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                },
                {
                    "as": "AcceptedPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if (completedStates.indexOf(ss) > -1) {
                            if (aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                }
            ];
        },

        getMetrics: function () {
            return [
                {
                    "field": "RemainingPoints",
                    "as": "To Do",
                    "f": "sum"
                },
                {
                    "field": "AcceptedPoints",
                    "as": "Accepted",
                    "f": "sum"
                }
            ];
        },

        getSummaryMetricsConfig: function () {
            return [
                {
                    'as': 'Scope_max',
                    'f': function(seriesData) {
                            var max = 0, i = 0;
                            max = seriesData[seriesData.length-1]['To Do'];
                            return max;
                         }
                }
            ];
        },

        getDerivedFieldsAfterSummary: function () {
            return  [
                {
                    "as": "Ideal",
                    "f": function (row, index, summaryMetrics, seriesData) {
                        var max = summaryMetrics.Scope_max,
                            increments = seriesData.length - 1,
                            incrementAmount;
                        if(increments === 0) {
                            return max;
                        }
                        incrementAmount = max / increments;
                        return Math.floor(100 * (max - index * incrementAmount)) / 100;
                    },
                    "display": "line"
                }
            ];
        },

        getProjectionsConfig: function () {
            var days = (this.scopeEndDate.getTime() -
                Rally.util.DateTime.fromIsoString(this.startDate).getTime()) / (24*1000*60*60);
            var doubleTimeboxEnd = Ext.Date.add(Rally.util.DateTime.fromIsoString(this.startDate), Ext.Date.DAY, (Math.floor(days) * 2) - 1);
            var timeboxEnd = Ext.Date.add(this.scopeEndDate, Ext.Date.DAY, -1);
            if(this.projectionsConfig === undefined) {
                this.projectionsConfig = {
                    doubleTimeboxEnd: timeboxEnd,
                    timeboxEnd: timeboxEnd,

                    series: [
                        {
                            "as": "Prediction",
                            "field": "To Do"
                        }
                    ],
                    continueWhile: function (point) {
                        var dt = Rally.util.DateTime.fromIsoString(point.tick);
                        var end = (this.series[0].slope >= 0) ? this.timeboxEnd : this.doubleTimeboxEnd;
                        return point.Prediction > 0 && dt < end;
                    }
                };
            }
            return this.projectionsConfig;
        },

        _firstNonZero: function(data) {
             var i;
             for(i=0;i<data.length;i++) {
                if(data[i] > 0) {
                    return i;
                }
             }
             return 0;
        },

        _leastSquares: function(todoValues, firstIndex, lastIndex) {
            var n = (lastIndex + 1) - firstIndex;
            var i;
            var sumx = 0.0, sumx2 = 0.0, sumy = 0.0, sumy2 = 0.0, sumxy = 0.0;
            var slope, yintercept;

            //Compute sums of x, x^2, y, y^2, and xy
            for (i = firstIndex; i <= lastIndex; i++) {
                sumx  = sumx  + i;
                sumx2 = sumx2 + i * i;
                sumy  = sumy  + todoValues[i];
                sumy2 = sumy2 + todoValues[i] * todoValues[i];
                sumxy = sumxy + i * todoValues[i];
            }
            slope = (n * sumxy - sumx * sumy) / (n * sumx2 - sumx * sumx);
            yintercept = (sumy * sumx2 - sumx * sumxy) / (n * sumx2 - sumx * sumx);

            return {slope: slope, yintercept: yintercept};
        },

        runCalculation: function (snapshots) {
            var chartData = this.callParent(arguments);

            if(chartData && chartData.projections && chartData.projections.series[0].slope > 0) {
            // if the slope is positive, try using least squares.  If that's also positive, then use the first result
                var todoData = chartData.series[0].data;
                var firstTodoIndex = this._firstNonZero(todoData),
                    lastTodoIndex = (todoData.length - 1) - chartData.projections.pointsAddedCount;

                var results = this._leastSquares(todoData, firstTodoIndex, lastTodoIndex);

                // override the prediction line only if least squares says the slope isn't positive
                if(results.slope <= 0) {
                    this.projectionsConfig.series[0].slope = results.slope;

                    chartData = this.callParent(arguments);

                    // project the plot back to the first todo value
                    chartData.series[3].data[firstTodoIndex] = ((results.slope * firstTodoIndex) + results.yintercept) + (chartData.series[3].data[lastTodoIndex] - ((results.slope * lastTodoIndex) + results.yintercept));
                    chartData.series[3].connectNulls = true;
                    this.projectionsConfig = undefined;
                } else {
                // DE18732, if the slope is up, truncate it at 1.25 of the max Ideal
//                    var predictionCeiling = 1.25 * chartData.series[2].data[0];
//                    if (_.max(chartData.series[3].data) > predictionCeiling) {
//                        var i;
//                        var maxVal = predictionCeiling;
//                        for(i=0;i < chartData.series[3].data.length;i++) {
//                            if(chartData.series[3].data[i] > predictionCeiling) {
//                                chartData.series[3].data[i] = maxVal;
//                                maxVal = null;
//                            }
//                        }
//                    }
                }

            }

            if(new Date() < this.scopeEndDate) {
                this._recomputeIdeal(chartData, this.scopeEndDate);
            }

            return chartData;
        },

        _recomputeIdeal: function(chartData, endDate) {
             var index;
             if(chartData.categories.length < 1) {
                return;
             }
             if(this.workDays.length < 1) {
                return;
             }

             var lastDate = Ext.Date.parse(chartData.categories[chartData.categories.length - 1], 'Y-m-d');
             console.log("END DAte: ", endDate);
             console.log("lastDate: ", lastDate);
             if(endDate > lastDate) {
                // the scopeEndDate date wasn't found in the current categories...we need to extend categories to include it
                // (honoring "workDays").
                 console.log("last date is earlier, add more dates");

                index = chartData.categories.length;
                var dt = Ext.Date.add(lastDate, Ext.Date.DAY, 1);
                while (dt < endDate) {
                    while (this.workDays.indexOf(Ext.Date.format(dt, 'l')) === -1) {
                        dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                    }
                    if (dt < endDate) {
                        chartData.categories[index++] = Ext.Date.format(dt, 'Y-m-d');
                    }
                    dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                }
                index = chartData.categories.length - 1;
             } else {
                 // it is in "scope"...set index to the index of the last workday in scope
                 console.log("last date is later");
                 index = this._indexOfDate(chartData, endDate);
                 if(index === -1) {
                    // it's in "scope", but falls on a non-workday...back up to the previous workday
                    while (this.workDays.indexOf(Ext.Date.format(endDate, 'l')) === -1) {
                        endDate = Ext.Date.add(endDate, Ext.Date.DAY, -1);
                        index = this._indexOfDate(chartData, endDate);
                    }
                 }
             }
             if(index < 0) {
                return;
             }
             // set first and last point, and let connectNulls fill in the rest
             var seriesData = chartData.series[2].data;
             var todoData = chartData.series[0].data;
             console.log("todoData: ", todoData);
             seriesData[0] = null;
             
             var tik = 0;             
             while (todoData[++tik] !== null) { 
                 console.log(tik, " : ", todoData[tik]);                 
                 seriesData[tik] = null;
             }
             console.log("tik: ", tik);
             seriesData[tik-1] = todoData[tik-1];
             
             console.log("ideal data: ", seriesData);
             
             seriesData[seriesData.length-1] = 0;
        },

        _indexOfDate: function(chartData, date) {
             var dateStr = Ext.Date.format(date, 'Y-m-d');
             return chartData.categories.indexOf(dateStr);
        },

        _removeFutureSeries: function (chartData, seriesIndex, dayIndex) {
            if(chartData.series[seriesIndex].data.length > dayIndex) {
                while(++dayIndex < chartData.series[seriesIndex].data.length) {
                    chartData.series[seriesIndex].data[dayIndex] = null;
                }
            }
        },

        _projectionsSlopePositive: function (chartData) {
            if(chartData.projections && chartData.projections.series) {
                return chartData.projections.series[0].slope >= 0;
            }

            return true;
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.charts.burndown.ReleaseBurnDownApp', {
        extend: 'Rally.apps.charts.burndown.BurnDownApp',
        integrationHeaders : {
            name: 'Release Burndown'
        }
    });
}());


            Rally.launchApp('Rally.apps.charts.burndown.ReleaseBurnDownApp', {
                name:"Release Burndown",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        @grey1: #F6F6F6;
@grey2: #E6E6E6;
@grey3: #D6D6D6;
@grey4: #C0C0C0;
@grey6: #888888;
@grey7: #666666;
@grey8: #444444;
@grey9: #222222;
@lime: #8DC63F;
@cyan: #00A9E0;
@proxima-nova-semi-bold: ProximaNovaSemiBold, Helvetica, Arial;
@proxima-nova-light: ProximaNovaLight, Helvetica, Arial;
@proxima-nova: ProximaNova, Helvetica, Arial;
    </style>
    <style type="text/css">
                .stat-panel .collapsed-widget,
.stat-panel .collapsed-widget > div {
  display: none;
}
.stat-panel .expanded-widget,
.stat-panel .expanded-widget > div {
  display: block;
}
.stat-panel.collapsed .collapsed-widget,
.stat-panel.collapsed .collapsed-widget > div {
  display: inline-block;
}
.stat-panel.collapsed .expanded-widget,
.stat-panel.collapsed .expanded-widget > div {
  display: none;
}
.stats-banner .stat-panel {
  border-top: 1px solid #d6d6d6;
  border-left: 1px solid #d6d6d6;
  border-bottom: 1px solid #d6d6d6;
  height: 110px;
  text-align: center;
}
.stats-banner .stat-panel:first-child {
  border-left: 0;
}
.stats-banner .stat-panel:last-child {
  border-left-width: 2px;
}
.stats-banner .stat-panel .stat-title {
  color: #222222;
  font-family: ProximaNovaSemiBold, Helvetica, Arial;
  font-size: 14px;
  padding-top: 5px;
}
.stats-banner .stat-panel .stat-metric {
  color: #666666;
  font-family: ProximaNovaLight, Helvetica, Arial;
  font-size: 18px;
  height: 85px;
  padding-top: 20px;
}
.stats-banner .stat-panel .stat-metric .metric-percent {
  display: inline;
  font-size: 12px;
  vertical-align: super;
}
.stats-banner .stat-panel .stat-metric .metric-icon {
  color: #888888;
  font-size: 18px;
  padding-right: 5px;
}
.stats-banner .stat-panel .stat-metric .metric-chart {
  position: absolute;
  top: 22px;
  width: 100%;
}
.stats-banner .stat-panel .stat-metric .metric-subtext {
  bottom: 7px;
  color: #888888;
  font-family: ProximaNova, Helvetica, Arial;
  font-size: 11px;
  position: absolute;
  text-transform: lowercase;
  width: 100%;
}
.stats-banner .stat-panel .stat-metric .metric-chart-text {
  position: absolute;
  top: 43px;
  width: 100%;
}
.stats-banner .stat-panel .stat-metric .metric-chart-text.percent-offset {
  left: 3px;
  top: 41px;
}
.stats-banner .stat-panel .stat-metric .stat-secondary {
  color: #888888;
  font-family: ProximaNova, Helvetica, Arial;
  font-size: 11px;
  text-transform: lowercase;
}
.stats-banner .stat-panel .stat-metric .stat-carousel {
  display: inline-block;
  font-family: ProximaNova, Helvetica, Arial;
  font-size: 12px;
  margin-top: -20px;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .rally-carousel-pane .x-box-inner {
  top: 0px !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .carousel > span {
  display: inline !important;
  width: auto !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .carousel > span > div {
  display: block !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .carousel .carousel-panel > span {
  display: inline !important;
  width: auto !important;
}
.stats-banner .stat-panel .stat-metric .stat-carousel .carousel .carousel-panel > span > div {
  display: block !important;
}
.stats-banner .stat-panel .chart .highcharts-container {
  cursor: pointer;
}
.stats-banner .stat-panel .gauge .chart .highcharts-container {
  cursor: default;
}
.stats-banner .stat-panel .header {
  display: none;
}
.stats-banner .stat-panel.collapse-expand {
  background-color: #f6f6f6;
  width: 23px;
}
.stats-banner .stat-panel.collapse-expand .toggle-icon {
  color: #c0c0c0;
  font-size: 18px;
  position: relative;
  right: 1px;
}
.stats-banner .stat-panel.collapse-expand:hover {
  cursor: pointer;
}
.stats-banner .stat-panel.collapse-expand:hover .toggle-icon {
  color: #888888;
}
.stats-banner.collapsed .stat-panel {
  height: 25px;
  padding-top: 2px;
}
.stats-banner.collapsed .stat-panel .metric-icon {
  color: #888888;
  font-size: 14px;
  padding-right: 5px;
  vertical-align: middle;
}
.stats-banner.collapsed .stat-panel .stat-title {
  color: #222222;
  display: inline;
  font-family: ProximaNovaSemiBold, Helvetica, Arial;
  font-size: 12px;
  vertical-align: middle;
}
.stats-banner.collapsed .stat-panel .stat-metric {
  color: #888888;
  display: inline;
  font-family: ProximaNova, Helvetica, Arial;
  font-size: 14px;
  height: auto;
  padding-top: auto;
  padding-left: 10px;
  vertical-align: middle;
}
.stats-banner.collapsed .stat-panel .stat-metric .stat-metric-secondary {
  font-size: 11px;
}
.stats-banner.collapsed .stat-panel .stat-metric .metric-percent {
  font-size: 10px;
  vertical-align: super;
}
.pie-chart-legend {
  color: #3E576F;
  font-size: 12px;
  padding: 5px;
  border: 1px solid #909090;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}
.pie-chart-legend .legend-swatch {
  width: 17px;
  height: 12px;
  border: 1px solid #EEE;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
  float: left;
  margin: 0 3px 0 6px;
}
.pie-chart-legend .legend-swatch.defined-sample-swatch {
  background: #E0E0E0;
  /* light-gray */
}
.pie-chart-legend .legend-swatch.in-progress-sample-swatch {
  background: #00a9e0;
}
.pie-chart-legend .legend-swatch.completed-sample-swatch {
  background: #8dc63f;
}
.pie-chart-legend .legend-swatch.blocked-sample-swatch {
  background: #EF3F35;
  /* rally red */
}
.iteration-progress-dialog .carousel .carousel-panel .scroll-button span {
  width: 45px;
  height: 50px;
  line-height: 46px;
}
.iteration-progress-dialog .carousel .carousel-panel .scroll-button span:hover {
  background-color: #e6e6e6;
  color: #666666;
}
.iteration-progress-toggle-button-group {
  margin-bottom: 5px;
}
.x-gecko .stats-banner.collapsed .stat-panel .stat-metric {
  line-height: 20px;
  vertical-align: top;
}
.x-gecko .stats-banner.collapsed .stat-panel .stat-metric .metric-percent {
  line-height: 10px;
}
.x-gecko.x-mac .stats-banner.collapsed .stat-panel .stat-metric {
  line-height: 22px;
}

    </style>
    <style type="text/css">
        .burndown-app .chartControls,
.app-settings .settings-form .paddedSettingCmp {
    margin: 15px;
    border: 0px;
}

.burndown-app .chartControls .rui-triggerfield {
    display: inline-block;
}

.burndown-app .chartControls label {
    display: inline-block;
    font-size: 1.2em;
    margin: 3px 8px;
}

.portfolio-cfd-app,
.portfolio-burnup-app,
.burndown-app {
    margin: 10px;
    padding-right: 20px;
    background-color: transparent;
}

.portfolio-cfd-app .rally-help-icon,
.burndown-app .rally-help-icon,
.portfolio-burnup-app .rally-help-icon,
.chart-app .rally-help-icon {
    float: right;
}

.portfolio-cfd-app .chart,
.portfolio-burnup-app .chart {
    min-height: 2em;
}

.app-settings .settings-form .piButton {
    padding: 5px 15px 7px 15px;
    z-index: 101;
    margin-bottom: 10px;
}

.app-settings .settings-form .piDisplayField {
    background-color: #e2eff6;
    margin-left: -10px;
    min-width: 250px;
    padding: 5px 20px 3px 25px;
    z-index: 100;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}

.app-settings .settings-form .settingsLabel {
    display: block;
    font-family: NotoSansBold, Helvetica, Arial;
    font-weight: normal;
    min-height: 20px;
    text-transform: uppercase;
    width: 100px;
}

table.settings-showLabels label {
    white-space: nowrap;
    width: auto;
}
table.settings-showLabels td {
    width:130px;
}

.schedule-state-selector .@{prefix}boundlist-selected .@{prefix}form-checkbox {
    background-position: 0 -13px;
}

.statefieldvalue-boundlist-item img.stateFieldValue {
    background: transparent url('checkbox.gif');
    height: 13px;
    width: 13px;
}
.statefieldvalue-boundlist-selected img.stateFieldValue{
    background: transparent url('checkbox.gif');
    height: 13px;
    width: 13px;
    background-position-x: 0px;
    background-position-y: -13px;
}

    </style>
</head>
<body></body>
</html>
